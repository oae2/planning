<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>Advanced PDF Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/qr-code-styling@1.5.0/lib/qr-code-styling.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sarabun:400,700|Prompt:400,700|Kanit:400,700|Mitr:400,700|Maitree:400,700|Pridi:400,700|Sriracha|Srisakdi:400,700|Taviraj:400,700|Niramit:400,700|Chonburi|Charmonman:400,700|Charm|Pattaya|Bai+Jamjuree:400,700|Mali:400,700|Sura:400,700|Noto+Sans+Thai:400,700|Noto+Serif+Thai:400,700|Arial:400,700|Times+New+Roman:400,700|Helvetica:400,700|Courier+New:400,700|Georgia:400,700|Verdana:400,700|Trebuchet+MS:400,700|Comic+Sans+MS:400,700|Impact:400,700|Lucida+Console:400,700&display=swap">
  <style>


  <!-- Security Protection CSS -->
  <style>
    /* ป้องกันการเลือกข้อความ (เฉพาะส่วนที่ไม่จำเป็น) */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* อนุญาตการเลือกในช่อง input และ textarea */
    input, textarea, [contenteditable="true"], button {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    
    /* ป้องกันการ drag & drop ภาพ */
    img {
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      user-drag: none;
    }
 <!-- Security Protection CSS -->


    .tool-card {
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .tool-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }
    .tool-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }
    .progress-bar {
      transition: width 0.3s ease;
    }
    .file-drop-zone {
      border: 2px dashed #e5e7eb;
      transition: all 0.3s ease;
    }
    .file-drop-zone.dragover {
      border-color: #3b82f6;
      background-color: #eff6ff;
    }
    .animate-bounce-gentle {
      animation: bounce-gentle 2s infinite;
    }
    @keyframes bounce-gentle {
      0%, 20%, 53%, 80%, 100% { transform: translateY(0); }
      40%, 43% { transform: translateY(-10px); }
      70% { transform: translateY(-5px); }
    }
    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .text-shadow {
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* PDF Card Styles */
    .pdf-card {
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      transition: all 0.3s ease;
      cursor: move;
      position: relative;
      background: white;
    }
    .pdf-card:hover {
      border-color: #ef4444;
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.15);
      transform: translateY(-2px);
    }
    .pdf-card.dragging {
      opacity: 0.5;
      transform: rotate(5deg) scale(0.95);
      z-index: 1000;
    }
    .pdf-card.drag-over {
      border-color: #ef4444;
      background-color: #fef2f2;
      border-style: dashed;
    }
    
    .pdf-thumbnail {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 8px 8px 0 0;
      background: #f8fafc;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .pdf-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .page-number {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      border-radius: 20px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }
    
    .remove-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .pdf-card:hover .remove-btn {
      opacity: 1;
    }
    
    .drag-placeholder {
      border: 2px dashed #ef4444;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ef4444;
      font-weight: 500;
      min-height: 280px;
    }
    
    .merge-area {
      min-height: 400px;
      padding: 20px;
      border-radius: 12px;
      background: #f8fafc;
      border: 2px dashed #d1d5db;
      transition: all 0.3s ease;
    }
    
    .merge-area.has-files {
      background: white;
      border: 1px solid #e5e7eb;
    }
    
    .control-panel {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 20px;
    }
    
    /* Split Tool Specific Styles */
    .split-tab-active {
      background: white !important;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
      color: #dc2626 !important;
    }
    
    .split-tab-inactive {
      color: #6b7280;
      background: transparent;
    }
    
    .split-tab-inactive:hover {
      background: #f9fafb;
    }
    
    .range-mode-active {
      border-color: #dc2626 !important;
      background-color: #fef2f2 !important;
      color: #dc2626 !important;
    }
    
    .range-mode-inactive {
      border-color: #e5e7eb;
      color: #6b7280;
    }
    
    .range-mode-inactive:hover {
      border-color: #fecaca;
    }
    
    /* PDF Page Thumbnail Styles */
    .pdf-page-item {
      position: relative;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
      aspect-ratio: 3/4;
    }
    
    .pdf-page-item:hover {
      border-color: #ef4444;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.15);
      transform: translateY(-2px);
    }
    
    .pdf-page-item.selected {
      border-color: #10b981;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
      transform: translateY(-2px);
    }
    
    .pdf-page-canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .page-number-badge {
      position: absolute;
      bottom: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 11px;
      font-weight: bold;
    }
    
    .selection-indicator {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #d1d5db;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .pdf-page-item.selected .selection-indicator {
      background: #10b981;
      border-color: #10b981;
      color: white;
    }
    
    .pdf-page-item.selected .selection-indicator::after {
      content: '✓';
      font-size: 12px;
      font-weight: bold;
    }

    /* Edit PDF Styles */
    body { 
      font-family: 'Sarabun', 'Prompt', 'Kanit', Arial, sans-serif; 
    }
    .toolbar-btn { 
      width: 48px; 
      height: 48px; 
      border-radius: 0.5rem; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      margin-bottom: 0.5rem; 
      font-size: 1.5rem; 
      background: none; 
      border: 1px solid #e5e7eb;
      transition: all 0.3s ease;
    }
    .toolbar-btn:hover {
      background: #f3f4f6;
    }
    .toolbar-btn.active { 
      background: #3b82f6; 
      color: white; 
      border-color: #3b82f6;
    }
    #edit-prop-panel label { 
      font-weight: 500; 
      margin-top: 0.5rem; 
    }
    #edit-prop-panel input, #edit-prop-panel select { 
      width: 100%; 
      margin-bottom: 0.5rem; 
      border: 1px solid #ddd; 
      border-radius: 6px; 
      padding: 2px 6px; 
    }

    /* Signature Canvas Styles */
    #signature-canvas {
      border: 2px dashed #d1d5db;
      border-radius: 8px;
      cursor: crosshair;
    }

    /* Rotation Button Styles */
    .rotation-btn {
      width: 80px;
      height: 80px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid #e5e7eb;
      background: white;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .rotation-btn:hover {
      border-color: #ef4444;
      background: #fef2f2;
    }
    
    .rotation-btn.selected {
      border-color: #ef4444;
      background: #fef2f2;
      color: #ef4444;
    }

    /* Preview Styles */
    .preview-container {
      background: white;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .preview-canvas {
      border: 1px solid #d1d5db;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 0 auto;
      display: block;
      max-width: 100%;
      max-height: 400px;
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <!-- Header -->
  <header class="gradient-bg text-white py-6 shadow-lg">
    <div class="container mx-auto px-4">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-3xl font-bold text-shadow">🔧 Advanced PDF Tools</h1>
          <p class="text-blue-100 mt-1">เครื่องมือ PDF ครบครัน สไตล์ iLovePDF</p>
        </div>
        <button onclick="goBack()" class="bg-white bg-opacity-20 hover:bg-opacity-30 px-4 py-2 rounded-lg transition-all">
          ← กลับหน้าหลัก
        </button>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container mx-auto px-4 py-8">
    
    <!-- PDF Tools Grid -->
    <section id="pdf-tools-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      
      <!-- Merge PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('merge')">
        <div class="text-center">
          <div class="tool-icon text-red-500">📄📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Merge PDF</h3>
          <p class="text-gray-600 text-sm">รวมหลายไฟล์ PDF เป็นไฟล์เดียว</p>
        </div>
      </div>

      <!-- Split PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('split')">
        <div class="text-center">
          <div class="tool-icon text-orange-500">✂️📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Split PDF</h3>
          <p class="text-gray-600 text-sm">แยกหน้า PDF เป็นไฟล์แยกต่างหาก</p>
        </div>
      </div>

      <!-- Compress PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('compress')">
        <div class="text-center">
          <div class="tool-icon text-green-500">🗜️</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Compress PDF</h3>
          <p class="text-gray-600 text-sm">ลดขนาดไฟล์ PDF อย่างมีประสิทธิภาพ</p>
        </div>
      </div>

      <!-- Edit PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('edit')">
        <div class="text-center">
          <div class="tool-icon text-purple-500">✏️</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Edit PDF</h3>
          <p class="text-gray-600 text-sm">แก้ไขข้อความและรูปภาพใน PDF</p>
        </div>
      </div>

      <!-- PDF to Word -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('pdf-to-word')">
        <div class="text-center">
          <div class="tool-icon text-blue-500">📄→📝</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">PDF to Word</h3>
          <p class="text-gray-600 text-sm">แปลง PDF เป็น Word (.docx)</p>
        </div>
      </div>

      <!-- Word to PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('word-to-pdf')">
        <div class="text-center">
          <div class="tool-icon text-blue-600">📝→📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Word to PDF</h3>
          <p class="text-gray-600 text-sm">แปลง Word เป็น PDF</p>
        </div>
      </div>

      <!-- PDF to PowerPoint -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('pdf-to-ppt')">
        <div class="text-center">
          <div class="tool-icon text-orange-600">📄→📊</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">PDF to PowerPoint</h3>
          <p class="text-gray-600 text-sm">แปลง PDF เป็น PowerPoint</p>
        </div>
      </div>

      <!-- PowerPoint to PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('ppt-to-pdf')">
        <div class="text-center">
          <div class="tool-icon text-red-600">📊→📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">PowerPoint to PDF</h3>
          <p class="text-gray-600 text-sm">แปลง PowerPoint เป็น PDF</p>
        </div>
      </div>

      <!-- PDF to Excel -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('pdf-to-excel')">
        <div class="text-center">
          <div class="tool-icon text-green-600">📄→📈</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">PDF to Excel</h3>
          <p class="text-gray-600 text-sm">แปลง PDF เป็น Excel</p>
        </div>
      </div>

      <!-- Excel to PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('excel-to-pdf')">
        <div class="text-center">
          <div class="tool-icon text-green-700">📈→📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Excel to PDF</h3>
          <p class="text-gray-600 text-sm">แปลง Excel เป็น PDF</p>
        </div>
      </div>

      <!-- PDF to JPG -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('pdf-to-jpg')">
        <div class="text-center">
          <div class="tool-icon text-yellow-500">📄→🖼️</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">PDF to JPG</h3>
          <p class="text-gray-600 text-sm">แปลง PDF เป็นรูปภาพ JPG</p>
        </div>
      </div>

      <!-- JPG to PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('jpg-to-pdf')">
        <div class="text-center">
          <div class="tool-icon text-yellow-600">🖼️→📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">JPG to PDF</h3>
          <p class="text-gray-600 text-sm">แปลงรูปภาพ JPG เป็น PDF</p>
        </div>
      </div>

      <!-- Sign PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('sign')">
        <div class="text-center">
          <div class="tool-icon text-indigo-500">✍️</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Sign PDF</h3>
          <p class="text-gray-600 text-sm">เซ็นลายเซ็นในเอกสาร PDF</p>
        </div>
      </div>

      <!-- Watermark PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('watermark')">
        <div class="text-center">
          <div class="tool-icon text-cyan-500">💧</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Watermark</h3>
          <p class="text-gray-600 text-sm">เพิ่มลายน้ำใน PDF</p>
        </div>
      </div>

      <!-- Rotate PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('rotate')">
        <div class="text-center">
          <div class="tool-icon text-pink-500">🔄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Rotate PDF</h3>
          <p class="text-gray-600 text-sm">หมุนหน้า PDF</p>
        </div>
      </div>

      <!-- Unlock PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('unlock')">
        <div class="text-center">
          <div class="tool-icon text-emerald-500">🔓</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Unlock PDF</h3>
          <p class="text-gray-600 text-sm">ปลดล็อครหัสผ่าน PDF</p>
        </div>
      </div>

      <!-- Protect PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('protect')">
        <div class="text-center">
          <div class="tool-icon text-slate-500">🔒</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">Protect PDF</h3>
          <p class="text-gray-600 text-sm">ใส่รหัสผ่านป้องกัน PDF</p>
        </div>
      </div>

      <!-- HTML to PDF -->
      <div class="tool-card bg-white rounded-xl p-6 shadow-md hover:shadow-xl" onclick="openTool('html-to-pdf')">
        <div class="text-center">
          <div class="tool-icon text-amber-500">🌐→📄</div>
          <h3 class="text-xl font-semibold text-gray-800 mb-2">HTML to PDF</h3>
          <p class="text-gray-600 text-sm">แปลงเว็บเพจ HTML เป็น PDF</p>
        </div>
      </div>

    </section>

    <!-- Sign PDF Tool -->
    <section id="sign-tool" class="hidden">
      <div class="max-w-6xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">✍️ Sign PDF File</h2>
          <p class="text-gray-600">เพิ่มลายเซ็นหรือข้อความลงในเอกสาร PDF</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <!-- Main Content Area -->
          <div class="lg:col-span-3">
            <!-- File Upload -->
            <div id="sign-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">✍️</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการใส่ลายเซ็น</p>
              <input type="file" id="sign-file" accept=".pdf" class="hidden">
              <button onclick="document.getElementById('sign-file').click()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>

            <!-- PDF Preview -->
            <div id="sign-preview" class="hidden bg-white rounded-lg shadow-lg p-6 mb-6">
              <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">PDF Preview</h3>
                <div class="flex items-center gap-2">
                  <button onclick="prevSignPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">⬅️</button>
                  <span id="sign-page-info" class="px-2 text-sm">1/1</span>
                  <button onclick="nextSignPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">➡️</button>
                </div>
              </div>
              <div class="border rounded-lg bg-gray-50 p-4 text-center">
                <canvas id="sign-pdf-canvas" class="border rounded shadow-sm mx-auto" style="max-width: 100%; height: auto;"></canvas>
              </div>
            </div>

            <!-- Signature Canvas (when Draw is selected) -->
            <div id="signature-draw-area" class="hidden bg-white rounded-lg shadow-lg p-6 mb-6">
              <h3 class="text-lg font-semibold mb-4">วาดลายเซ็น</h3>
              <div class="mb-4">
                <canvas id="signature-canvas" width="400" height="200" class="mx-auto"></canvas>
              </div>
              <div class="flex justify-center gap-4">
                <button onclick="clearSignature()" class="bg-gray-500 text-white px-4 py-2 rounded">ล้าง</button>
                <button onclick="saveSignature()" class="bg-indigo-600 text-white px-4 py-2 rounded">บันทึกลายเซ็น</button>
              </div>
            </div>

            <!-- Progress -->
            <div id="sign-progress" class="hidden">
              <div class="bg-gray-200 rounded-full h-4 overflow-hidden mb-2">
                <div id="sign-progress-bar" class="progress-bar bg-indigo-600 h-full" style="width: 0%"></div>
              </div>
              <p class="text-center text-sm text-gray-600">กำลังประมวลผล... <span id="sign-progress-text">0%</span></p>
            </div>

            <!-- Result with Preview -->
            <div id="sign-result" class="hidden bg-green-50 border border-green-200 rounded-lg p-6">
              <h3 class="text-lg font-semibold text-green-800 mb-4">✅ เซ็นลายเซ็นสำเร็จ!</h3>
              <p class="text-green-700 mb-4">เอกสาร PDF ได้รับการเซ็นลายเซ็นเรียบร้อยแล้ว</p>
              
              <!-- Preview Section -->
              <div id="sign-result-preview" class="preview-container">
                <h4 class="text-md font-semibold text-gray-800 mb-3">ตัวอย่างผลลัพธ์:</h4>
                <div class="flex justify-between items-center mb-3">
                  <span class="text-sm text-gray-600">หน้าที่มีลายเซ็น</span>
                  <div class="flex items-center gap-2">
                    <button onclick="prevSignPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">⬅️</button>
                    <span id="sign-preview-info" class="px-2 text-sm">1/1</span>
                    <button onclick="nextSignPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">➡️</button>
                  </div>
                </div>
                <div class="text-center">
                  <canvas id="sign-result-canvas" class="preview-canvas"></canvas>
                </div>
              </div>
              
              <button onclick="downloadSignedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                📥 ดาวน์โหลดไฟล์ที่เซ็นแล้ว
              </button>
            </div>
          </div>

          <!-- Right Sidebar: Sign Options -->
          <div class="lg:col-span-1">
            <div class="bg-white rounded-lg shadow-lg p-6 sticky top-6">
              <h3 class="text-lg font-bold text-gray-800 mb-6 text-center">Sign Options</h3>

              <!-- Signature Type -->
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-3">ประเภทลายเซ็น:</label>
                <div class="space-y-2">
                  <label class="flex items-center p-3 border border-indigo-500 bg-indigo-50 rounded-lg cursor-pointer">
                    <input type="radio" name="sign-type" value="draw" class="mr-3 text-indigo-600" checked>
                    <div>
                      <div class="font-medium text-indigo-600">วาดลายเซ็น</div>
                      <div class="text-xs text-gray-500">วาดลายเซ็นด้วยเมาส์หรือสัมผัส</div>
                    </div>
                  </label>
                  <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-indigo-200">
                    <input type="radio" name="sign-type" value="text" class="mr-3 text-indigo-600">
                    <div>
                      <div class="font-medium text-gray-700">ลายเซ็นข้อความ</div>
                      <div class="text-xs text-gray-500">พิมพ์ชื่อเป็นลายเซ็น</div>
                    </div>
                  </label>
                  <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-indigo-200">
                    <input type="radio" name="sign-type" value="upload" class="mr-3 text-indigo-600">
                    <div>
                      <div class="font-medium text-gray-700">อัปโหลดรูปลายเซ็น</div>
                      <div class="text-xs text-gray-500">ใช้รูปลายเซ็นที่มีอยู่</div>
                    </div>
                  </label>
                </div>
              </div>

              <!-- Text Signature Options -->
              <div id="text-sign-options" class="hidden mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">ข้อความลายเซ็น:</label>
                <input type="text" id="sign-text" class="w-full p-3 border border-gray-300 rounded-lg mb-3" placeholder="พิมพ์ชื่อของคุณ">
                <label class="block text-sm font-medium text-gray-700 mb-2">ฟอนต์:</label>
                <select id="sign-font" class="w-full p-3 border border-gray-300 rounded-lg mb-3">
                  <option value="Sarabun">Sarabun</option>
                  <option value="Prompt">Prompt</option>
                  <option value="Kanit">Kanit</option>
                  <option value="Dancing Script">Dancing Script</option>
                  <option value="Caveat">Caveat</option>
                </select>
                <label class="block text-sm font-medium text-gray-700 mb-2">ขนาด:</label>
                <input type="range" id="sign-size" min="20" max="60" value="32" class="w-full">
                <div class="text-center text-sm text-gray-600"><span id="sign-size-value">32</span>px</div>
              </div>

              <!-- Upload Signature Options -->
              <div id="upload-sign-options" class="hidden mb-6">
                <input type="file" id="sign-image" accept="image/*" class="hidden">
                <button onclick="document.getElementById('sign-image').click()" class="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-center hover:border-indigo-300">
                  📷 เลือกรูปลายเซ็น
                </button>
                <div id="sign-image-preview" class="hidden mt-3 text-center">
                  <img id="preview-img" class="max-w-full h-20 mx-auto border rounded">
                </div>
              </div>

              <!-- Position Options -->
              <div id="position-options" class="hidden mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">ตำแหน่งลายเซ็น:</label>
                <div class="grid grid-cols-3 gap-2 mb-3">
                  <button onclick="setSignPosition('top-left')" class="p-2 border rounded text-xs hover:bg-gray-50">บนซ้าย</button>
                  <button onclick="setSignPosition('top-center')" class="p-2 border rounded text-xs hover:bg-gray-50">บนกลาง</button>
                  <button onclick="setSignPosition('top-right')" class="p-2 border rounded text-xs hover:bg-gray-50">บนขวา</button>
                  <button onclick="setSignPosition('center-left')" class="p-2 border rounded text-xs hover:bg-gray-50">กลางซ้าย</button>
                  <button onclick="setSignPosition('center')" class="p-2 border rounded text-xs hover:bg-gray-50">กลาง</button>
                  <button onclick="setSignPosition('center-right')" class="p-2 border rounded text-xs hover:bg-gray-50">กลางขวา</button>
                  <button onclick="setSignPosition('bottom-left')" class="p-2 border rounded text-xs hover:bg-gray-50">ล่างซ้าย</button>
                  <button onclick="setSignPosition('bottom-center')" class="p-2 border rounded text-xs hover:bg-gray-50">ล่างกลาง</button>
                  <button onclick="setSignPosition('bottom-right')" class="p-2 border rounded text-xs hover:bg-gray-50 bg-indigo-50 border-indigo-300">ล่างขวา</button>
                </div>
                <label class="block text-sm font-medium text-gray-700 mb-2">หน้าที่จะเซ็น:</label>
                <select id="sign-page-select" class="w-full p-2 border border-gray-300 rounded">
                  <option value="last">หน้าสุดท้าย</option>
                  <option value="first">หน้าแรก</option>
                  <option value="all">ทุกหน้า</option>
                </select>
              </div>

              <!-- Apply Button -->
              <div class="mt-6">
                <button id="apply-sign-btn" onclick="executeSign()" class="w-full bg-indigo-600 text-white py-4 rounded-lg text-lg font-semibold hover:bg-indigo-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                  <span class="mr-2">✍️</span>เซ็นลายเซ็น
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Watermark PDF Tool -->
    <section id="watermark-tool" class="hidden">
      <div class="max-w-6xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">💧 Add Watermark to PDF</h2>
          <p class="text-gray-600">เพิ่มลายน้ำข้อความหรือรูปภาพลงใน PDF</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <!-- Main Content Area -->
          <div class="lg:col-span-3">
            <!-- File Upload -->
            <div id="watermark-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">💧</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการใส่ลายน้ำ</p>
              <input type="file" id="watermark-file" accept=".pdf" class="hidden">
              <button onclick="document.getElementById('watermark-file').click()" class="bg-cyan-600 text-white px-6 py-3 rounded-lg hover:bg-cyan-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>

            <!-- PDF Preview -->
            <div id="watermark-preview" class="hidden bg-white rounded-lg shadow-lg p-6 mb-6">
              <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">PDF Preview</h3>
                <div class="flex items-center gap-2">
                  <button onclick="prevWatermarkPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">⬅️</button>
                  <span id="watermark-page-info" class="px-2 text-sm">1/1</span>
                  <button onclick="nextWatermarkPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">➡️</button>
                </div>
              </div>
              <div class="border rounded-lg bg-gray-50 p-4 text-center">
                <canvas id="watermark-pdf-canvas" class="border rounded shadow-sm mx-auto" style="max-width: 100%; height: auto;"></canvas>
              </div>
            </div>

            <!-- Progress -->
            <div id="watermark-progress" class="hidden">
              <div class="bg-gray-200 rounded-full h-4 overflow-hidden mb-2">
                <div id="watermark-progress-bar" class="progress-bar bg-cyan-600 h-full" style="width: 0%"></div>
              </div>
              <p class="text-center text-sm text-gray-600">กำลังเพิ่มลายน้ำ... <span id="watermark-progress-text">0%</span></p>
            </div>

            <!-- Result with Preview -->
            <div id="watermark-result" class="hidden bg-green-50 border border-green-200 rounded-lg p-6">
              <h3 class="text-lg font-semibold text-green-800 mb-4">✅ เพิ่มลายน้ำสำเร็จ!</h3>
              <p class="text-green-700 mb-4">ลายน้ำได้ถูกเพิ่มลงใน PDF เรียบร้อยแล้ว</p>
              
              <!-- Preview Section -->
              <div id="watermark-result-preview" class="preview-container">
                <h4 class="text-md font-semibold text-gray-800 mb-3">ตัวอย่างผลลัพธ์:</h4>
                <div class="flex justify-between items-center mb-3">
                  <span class="text-sm text-gray-600">หน้าที่มีลายน้ำ</span>
                  <div class="flex items-center gap-2">
                    <button onclick="prevWatermarkPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">⬅️</button>
                    <span id="watermark-preview-info" class="px-2 text-sm">1/1</span>
                    <button onclick="nextWatermarkPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">➡️</button>
                  </div>
                </div>
                <div class="text-center">
                  <canvas id="watermark-result-canvas" class="preview-canvas"></canvas>
                </div>
              </div>
              
              <button onclick="downloadWatermarkedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                📥 ดาวน์โหลดไฟล์ที่มีลายน้ำ
              </button>
            </div>
          </div>

          <!-- Right Sidebar: Watermark Options -->
          <div class="lg:col-span-1">
            <div class="bg-white rounded-lg shadow-lg p-6 sticky top-6">
              <h3 class="text-lg font-bold text-gray-800 mb-6 text-center">Watermark</h3>

              <!-- Watermark Type -->
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-3">ประเภทลายน้ำ:</label>
                <div class="space-y-2">
                  <label class="flex items-center p-3 border border-cyan-500 bg-cyan-50 rounded-lg cursor-pointer">
                    <input type="radio" name="watermark-type" value="text" class="mr-3 text-cyan-600" checked>
                    <div>
                      <div class="font-medium text-cyan-600">ลายน้ำข้อความ</div>
                      <div class="text-xs text-gray-500">เพิ่มข้อความเป็นลายน้ำ</div>
                    </div>
                  </label>
                  <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-cyan-200">
                    <input type="radio" name="watermark-type" value="image" class="mr-3 text-cyan-600">
                    <div>
                      <div class="font-medium text-gray-700">ลายน้ำรูปภาพ</div>
                      <div class="text-xs text-gray-500">ใช้รูปภาพเป็นลายน้ำ</div>
                    </div>
                  </label>
                </div>
              </div>

              <!-- Text Watermark Options -->
              <div id="watermark-text-options" class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">ข้อความลายน้ำ:</label>
                <input type="text" id="watermark-text" class="w-full p-3 border border-gray-300 rounded-lg mb-3" placeholder="ข้อความลายน้ำ" value="CONFIDENTIAL">
                
                <label class="block text-sm font-medium text-gray-700 mb-2">ฟอนต์:</label>
                <select id="watermark-font" class="w-full p-3 border border-gray-300 rounded-lg mb-3">
                  <option value="Sarabun">Sarabun</option>
                  <option value="Prompt">Prompt</option>
                  <option value="Kanit">Kanit</option>
                  <option value="Arial">Arial</option>
                </select>
                
                <label class="block text-sm font-medium text-gray-700 mb-2">ขนาด:</label>
                <input type="range" id="watermark-size" min="20" max="100" value="48" class="w-full mb-2">
                <div class="text-center text-sm text-gray-600"><span id="watermark-size-value">48</span>px</div>
                
                <label class="block text-sm font-medium text-gray-700 mb-2">สี:</label>
                <input type="color" id="watermark-color" value="#808080" class="w-full h-10 border border-gray-300 rounded-lg mb-3">
                
                <label class="block text-sm font-medium text-gray-700 mb-2">ความโปร่งใส:</label>
                <input type="range" id="watermark-opacity" min="10" max="100" value="30" class="w-full mb-2">
                <div class="text-center text-sm text-gray-600"><span id="watermark-opacity-value">30</span>%</div>
              </div>

              <!-- Image Watermark Options -->
              <div id="watermark-image-options" class="hidden mb-6">
                <input type="file" id="watermark-image" accept="image/*" class="hidden">
                <button onclick="document.getElementById('watermark-image').click()" class="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-center hover:border-cyan-300 mb-3">
                  📷 เลือกรูปลายน้ำ
                </button>
                <div id="watermark-image-preview" class="hidden mb-3 text-center">
                  <img id="watermark-preview-img" class="max-w-full h-20 mx-auto border rounded">
                </div>
                
                <label class="block text-sm font-medium text-gray-700 mb-2">ขนาดรูป (%):</label>
                <input type="range" id="watermark-scale" min="10" max="100" value="50" class="w-full mb-2">
                <div class="text-center text-sm text-gray-600"><span id="watermark-scale-value">50</span>%</div>
                
                <label class="block text-sm font-medium text-gray-700 mb-2">ความโปร่งใส:</label>
                <input type="range" id="watermark-img-opacity" min="10" max="100" value="50" class="w-full mb-2">
                <div class="text-center text-sm text-gray-600"><span id="watermark-img-opacity-value">50</span>%</div>
              </div>

              <!-- Position Options -->
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">ตำแหน่งลายน้ำ:</label>
                <div class="grid grid-cols-3 gap-2 mb-3">
                  <button onclick="setWatermarkPosition('top-left')" class="p-2 border rounded text-xs hover:bg-gray-50">บนซ้าย</button>
                  <button onclick="setWatermarkPosition('top-center')" class="p-2 border rounded text-xs hover:bg-gray-50">บนกลาง</button>
                  <button onclick="setWatermarkPosition('top-right')" class="p-2 border rounded text-xs hover:bg-gray-50">บนขวา</button>
                  <button onclick="setWatermarkPosition('center-left')" class="p-2 border rounded text-xs hover:bg-gray-50">กลางซ้าย</button>
                  <button onclick="setWatermarkPosition('center')" class="p-2 border rounded text-xs hover:bg-gray-50 bg-cyan-50 border-cyan-300">กลาง</button>
                  <button onclick="setWatermarkPosition('center-right')" class="p-2 border rounded text-xs hover:bg-gray-50">กลางขวา</button>
                  <button onclick="setWatermarkPosition('bottom-left')" class="p-2 border rounded text-xs hover:bg-gray-50">ล่างซ้าย</button>
                  <button onclick="setWatermarkPosition('bottom-center')" class="p-2 border rounded text-xs hover:bg-gray-50">ล่างกลาง</button>
                  <button onclick="setWatermarkPosition('bottom-right')" class="p-2 border rounded text-xs hover:bg-gray-50">ล่างขวา</button>
                </div>
                
                <label class="block text-sm font-medium text-gray-700 mb-2">มุมหมุน:</label>
                <input type="range" id="watermark-rotation" min="-45" max="45" value="0" class="w-full mb-2">
                <div class="text-center text-sm text-gray-600"><span id="watermark-rotation-value">0</span>°</div>
              </div>

              <!-- Apply Button -->
              <div class="mt-6">
                <button id="apply-watermark-btn" onclick="executeWatermark()" class="w-full bg-cyan-600 text-white py-4 rounded-lg text-lg font-semibold hover:bg-cyan-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                  <span class="mr-2">💧</span>เพิ่มลายน้ำ
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Rotate PDF Tool -->
    <section id="rotate-tool" class="hidden">
      <div class="max-w-6xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">🔄 Rotate PDF Pages</h2>
          <p class="text-gray-600">หมุนหน้า PDF ตามองศาที่ต้องการ</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <!-- Main Content Area -->
          <div class="lg:col-span-3">
            <!-- File Upload -->
            <div id="rotate-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">🔄</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการหมุน</p>
              <input type="file" id="rotate-file" accept=".pdf" class="hidden">
              <button onclick="document.getElementById('rotate-file').click()" class="bg-pink-600 text-white px-6 py-3 rounded-lg hover:bg-pink-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>

            <!-- PDF Pages Grid -->
            <div id="rotate-pages-container" class="hidden">
              <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div id="rotate-file-details" class="text-blue-700 text-sm"></div>
              </div>
              
              <!-- Pages Grid -->
              <div id="rotate-pages-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 mb-6">
                <!-- PDF page thumbnails will be inserted here -->
              </div>
            </div>

            <!-- Progress -->
            <div id="rotate-progress" class="hidden">
              <div class="bg-gray-200 rounded-full h-4 overflow-hidden mb-2">
                <div id="rotate-progress-bar" class="progress-bar bg-pink-600 h-full" style="width: 0%"></div>
              </div>
              <p class="text-center text-sm text-gray-600">กำลังหมุนหน้า PDF... <span id="rotate-progress-text">0%</span></p>
            </div>

            <!-- Result with Preview -->
            <div id="rotate-result" class="hidden bg-green-50 border border-green-200 rounded-lg p-6">
              <h3 class="text-lg font-semibold text-green-800 mb-4">✅ หมุนหน้า PDF สำเร็จ!</h3>
              <p class="text-green-700 mb-4">หน้า PDF ได้ถูกหมุนตามที่ระบุเรียบร้อยแล้ว</p>
              
              <!-- Preview Section -->
              <div id="rotate-result-preview" class="preview-container">
                <h4 class="text-md font-semibold text-gray-800 mb-3">ตัวอย่างผลลัพธ์:</h4>
                <div class="flex justify-between items-center mb-3">
                  <span class="text-sm text-gray-600">หน้าที่ถูกหมุน</span>
                  <div class="flex items-center gap-2">
                    <button onclick="prevRotatePreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">⬅️</button>
                    <span id="rotate-preview-info" class="px-2 text-sm">1/1</span>
                    <button onclick="nextRotatePreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">➡️</button>
                  </div>
                </div>
                <div class="text-center">
                  <canvas id="rotate-result-canvas" class="preview-canvas"></canvas>
                </div>
              </div>
              
              <button onclick="downloadRotatedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                📥 ดาวน์โหลดไฟล์ที่หมุนแล้ว
              </button>
            </div>
          </div>

          <!-- Right Sidebar: Rotation Options -->
          <div class="lg:col-span-1">
            <div class="bg-white rounded-lg shadow-lg p-6 sticky top-6">
              <h3 class="text-lg font-bold text-gray-800 mb-6 text-center">Rotate</h3>

              <!-- Rotation Direction -->
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-3">เลือกการหมุน:</label>
                <div class="grid grid-cols-2 gap-3 mb-4">
                  <div onclick="setRotationDegree(90)" class="rotation-btn selected" id="rotate-90">
                    <div class="text-2xl mb-1">↻</div>
                    <div class="text-xs">90°</div>
                  </div>
                  <div onclick="setRotationDegree(180)" class="rotation-btn" id="rotate-180">
                    <div class="text-2xl mb-1">↻</div>
                    <div class="text-xs">180°</div>
                  </div>
                  <div onclick="setRotationDegree(270)" class="rotation-btn" id="rotate-270">
                    <div class="text-2xl mb-1">↺</div>
                    <div class="text-xs">270°</div>
                  </div>
                  <div onclick="setRotationDegree(-90)" class="rotation-btn" id="rotate--90">
                    <div class="text-2xl mb-1">↺</div>
                    <div class="text-xs">-90°</div>
                  </div>
                </div>
              </div>

              <!-- Page Selection -->
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-3">หน้าที่จะหมุน:</label>
                <div class="space-y-2">
                  <label class="flex items-center p-3 border border-pink-500 bg-pink-50 rounded-lg cursor-pointer">
                    <input type="radio" name="rotate-pages" value="all" class="mr-3 text-pink-600" checked>
                    <div>
                      <div class="font-medium text-pink-600">ทุกหน้า</div>
                      <div class="text-xs text-gray-500">หมุนทุกหน้าในไฟล์</div>
                    </div>
                  </label>
                  <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-pink-200">
                    <input type="radio" name="rotate-pages" value="selected" class="mr-3 text-pink-600">
                    <div>
                      <div class="font-medium text-gray-700">หน้าที่เลือก</div>
                      <div class="text-xs text-gray-500">หมุนเฉพาะหน้าที่เลือก</div>
                    </div>
                  </label>
                  <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-pink-200">
                    <input type="radio" name="rotate-pages" value="range" class="mr-3 text-pink-600">
                    <div>
                      <div class="font-medium text-gray-700">ช่วงหน้า</div>
                      <div class="text-xs text-gray-500">ระบุช่วงหน้าที่ต้องการ</div>
                    </div>
                  </label>
                </div>
              </div>

              <!-- Range Input -->
              <div id="rotate-range-input" class="hidden mb-6">
                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="block text-xs text-gray-500 mb-1">จากหน้า</label>
                    <input type="number" id="rotate-from-page" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="1">
                  </div>
                  <div>
                    <label class="block text-xs text-gray-500 mb-1">ถึงหน้า</label>
                    <input type="number" id="rotate-to-page" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="1">
                  </div>
                </div>
              </div>

              <!-- Selected Pages Info -->
              <div id="rotate-selected-info" class="hidden p-3 bg-blue-50 rounded-lg text-sm text-blue-700 mb-6">
                <div id="rotate-selected-count">เลือกหน้าที่จะหมุน</div>
              </div>

              <!-- Control Buttons -->
              <div class="space-y-2 mb-6">
                <button onclick="selectAllRotatePages()" class="w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-all text-sm">
                  เลือกทุกหน้า
                </button>
                <button onclick="deselectAllRotatePages()" class="w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-all text-sm">
                  ยกเลิกการเลือก
                </button>
              </div>

              <!-- Apply Button -->
              <div class="mt-6">
                <button id="apply-rotate-btn" onclick="executeRotate()" class="w-full bg-pink-600 text-white py-4 rounded-lg text-lg font-semibold hover:bg-pink-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                  <span class="mr-2">🔄</span>หมุน PDF
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Protect PDF Tool -->
    <section id="protect-tool" class="hidden">
      <div class="max-w-4xl mx-auto">
        <div class="bg-white rounded-xl shadow-lg p-8">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-gray-800 mb-2">🔒 Protect PDF with Password</h2>
            <p class="text-gray-600">เพิ่มรหัสผ่านเพื่อป้องกันการเข้าถึงไฟล์ PDF</p>
          </div>

          <!-- File Upload -->
          <div id="protect-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
            <div class="animate-bounce-gentle mb-4">
              <div class="text-6xl text-gray-400">🔒</div>
            </div>
            <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
            <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการใส่รหัสผ่าน</p>
            <input type="file" id="protect-file" accept=".pdf" class="hidden">
            <button onclick="document.getElementById('protect-file').click()" class="bg-slate-600 text-white px-6 py-3 rounded-lg hover:bg-slate-700 transition-all">
              เลือกไฟล์ PDF
            </button>
          </div>

          <!-- File Info -->
          <div id="protect-file-info" class="hidden mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <h3 class="text-lg font-semibold text-blue-800 mb-2">ข้อมูลไฟล์:</h3>
            <div id="protect-original-info" class="text-blue-700"></div>
          </div>

          <!-- Protection Options -->
          <div id="protect-options" class="hidden mb-6">
            <h3 class="text-lg font-semibold mb-4">ตั้งค่าการป้องกัน:</h3>
            
            <!-- Important Notice -->
            <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
              <div class="flex items-center gap-2 text-amber-800 mb-2">
                <span class="text-lg">⚠️</span>
                <strong>ข้อมูลสำคัญเกี่ยวกับการป้องกัน PDF</strong>
              </div>
              <div class="text-amber-700 text-sm">
                <ul class="list-disc list-inside space-y-1">
                  <li>เครื่องมือนี้จะเพิ่ม metadata บ่งบอกการป้องกัน</li>
                  <li>การป้องกันรหัสผ่านที่แท้จริงต้องใช้ไลบรารีเฉพาะทาง</li>
                  <li>สำหรับการใช้งานจริง แนะนำใช้ PDFtk, HummusJS หรือ Adobe Acrobat</li>
                  <li>ไฟล์ที่ได้จะแสดงข้อมูลการป้องกัน แต่ยังเปิดได้ปกติ</li>
                </ul>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <!-- Password Settings -->
              <div class="space-y-4">
                <h4 class="font-semibold text-gray-800">รหัสผ่าน:</h4>
                
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-2">รหัสผ่านสำหรับเปิดไฟล์:</label>
                  <input type="password" id="user-password" class="w-full p-3 border border-gray-300 rounded-lg" placeholder="ระบุรหัสผ่าน">
                  <p class="text-xs text-gray-500 mt-1">ต้องใส่รหัสผ่านนี้เพื่อเปิดดู PDF</p>
                </div>
                
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-2">รหัสผ่านสำหรับแก้ไข:</label>
                  <input type="password" id="owner-password" class="w-full p-3 border border-gray-300 rounded-lg" placeholder="ระบุรหัสผ่าน (ไม่บังคับ)">
                  <p class="text-xs text-gray-500 mt-1">ต้องใส่รหัสผ่านนี้เพื่อแก้ไข PDF</p>
                </div>

                <div class="flex items-center">
                  <input type="checkbox" id="show-passwords" class="mr-2">
                  <label for="show-passwords" class="text-sm">แสดงรหัสผ่าน</label>
                </div>
              </div>

              <!-- Permissions -->
              <div class="space-y-4">
                <h4 class="font-semibold text-gray-800">สิทธิ์การใช้งาน:</h4>
                
                <div class="space-y-3">
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-printing" class="mr-2" checked>
                    <span class="text-sm">อนุญาตให้พิมพ์</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-modify" class="mr-2">
                    <span class="text-sm">อนุญาตให้แก้ไขเนื้อหา</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-copy" class="mr-2">
                    <span class="text-sm">อนุญาตให้คัดลอกข้อความ</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-annotations" class="mr-2" checked>
                    <span class="text-sm">อนุญาตให้เพิ่มหมายเหตุ</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-forms" class="mr-2" checked>
                    <span class="text-sm">อนุญาตให้กรอกฟอร์ม</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-accessibility" class="mr-2" checked>
                    <span class="text-sm">อนุญาตให้เข้าถึงสำหรับผู้พิการ</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-assembly" class="mr-2">
                    <span class="text-sm">อนุญาตให้ประกอบเอกสาร</span>
                  </label>
                  
                  <label class="flex items-center">
                    <input type="checkbox" id="allow-degraded-printing" class="mr-2">
                    <span class="text-sm">อนุญาตให้พิมพ์คุณภาพต่ำ</span>
                  </label>
                </div>
              </div>
            </div>

            <!-- Security Level -->
            <div class="mt-6 p-4 bg-gray-50 rounded-lg">
              <h4 class="font-semibold text-gray-800 mb-3">ระดับความปลอดภัย:</h4>
              <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50">
                  <input type="radio" name="security-level" value="low" class="mr-3">
                  <div>
                    <div class="font-medium">ต่ำ</div>
                    <div class="text-xs text-gray-500">40-bit RC4</div>
                  </div>
                </label>
                <label class="flex items-center p-3 border border-slate-500 bg-slate-50 rounded-lg cursor-pointer">
                  <input type="radio" name="security-level" value="standard" class="mr-3" checked>
                  <div>
                    <div class="font-medium">มาตรฐาน</div>
                    <div class="text-xs text-gray-500">128-bit RC4</div>
                  </div>
                </label>
                <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50">
                  <input type="radio" name="security-level" value="high" class="mr-3">
                  <div>
                    <div class="font-medium">สูง</div>
                    <div class="text-xs text-gray-500">256-bit AES</div>
                  </div>
                </label>
              </div>
            </div>
          </div>

          <!-- Protect Button -->
          <div class="text-center">
            <button id="protect-btn" onclick="executeProtect()" class="bg-slate-600 text-white px-8 py-4 rounded-lg text-lg font-semibold hover:bg-slate-700 transition-all disabled:opacity-50" disabled>
              🔒 สร้างไฟล์ป้องกัน (Demo)
            </button>
            <p class="text-xs text-gray-500 mt-2">
              * ไฟล์จะมี metadata การป้องกัน แต่ยังเปิดได้ปกติ
            </p>
          </div>

          <!-- Progress -->
          <div id="protect-progress" class="hidden mt-6">
            <div class="bg-gray-200 rounded-full h-4 overflow-hidden">
              <div id="protect-progress-bar" class="progress-bar bg-slate-600 h-full" style="width: 0%"></div>
            </div>
            <p class="text-center text-sm text-gray-600 mt-2">กำลังป้องกันไฟล์... <span id="protect-progress-text">0%</span></p>
          </div>

          <!-- Result with Preview -->
          <div id="protect-result" class="hidden mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
            <h3 class="text-lg font-semibold text-green-800 mb-4">✅ ป้องกันไฟล์สำเร็จ!</h3>
            <div id="protect-stats" class="text-green-700 mb-4"></div>
            
            <!-- Preview Section -->
            <div id="protect-result-preview" class="preview-container">
              <h4 class="text-md font-semibold text-gray-800 mb-3">ตัวอย่างไฟล์ที่ป้องกัน:</h4>
              <div class="flex justify-between items-center mb-3">
                <span class="text-sm text-gray-600">ไฟล์ PDF ที่มีการป้องกัน</span>
                <div class="flex items-center gap-2">
                  <button onclick="prevProtectPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">⬅️</button>
                  <span id="protect-preview-info" class="px-2 text-sm">1/1</span>
                  <button onclick="nextProtectPreview()" class="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm">➡️</button>
                </div>
              </div>
              <div class="text-center">
                <canvas id="protect-result-canvas" class="preview-canvas"></canvas>
              </div>
            </div>
            
            <button onclick="downloadProtectedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
              📥 ดาวน์โหลดไฟล์ที่ป้องกันแล้ว
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- Merge PDF Tool -->
    <section id="merge-tool" class="hidden">
      <div class="max-w-7xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">📄 Merge PDF Files</h2>
          <p class="text-gray-600">รวมหลายไฟล์ PDF เป็นไฟล์เดียว โดยรักษาคุณภาพเดิม</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <!-- Main Merge Area -->
          <div class="lg:col-span-3">
            <!-- File Drop Zone -->
            <div id="merge-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">📁</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">รองรับไฟล์ PDF หลายไฟล์</p>
              <input type="file" id="merge-files" multiple accept=".pdf" class="hidden">
              <button onclick="document.getElementById('merge-files').click()" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>

            <!-- PDF Grid -->
            <div id="merge-area" class="merge-area">
              <div id="empty-state" class="text-center py-20">
                <div class="text-6xl text-gray-300 mb-4">📄</div>
                <h3 class="text-lg font-medium text-gray-500 mb-2">ยังไม่มีไฟล์ PDF</h3>
                <p class="text-gray-400">ลากไฟล์มาวางที่นี่ หรือเลือกไฟล์ด้านบน</p>
              </div>
              <div id="pdf-grid" class="pdf-grid hidden"></div>
            </div>

            <!-- Progress -->
            <div id="merge-progress" class="hidden mt-6">
              <div class="bg-gray-200 rounded-full h-4 overflow-hidden">
                <div id="merge-progress-bar" class="progress-bar bg-red-600 h-full" style="width: 0%"></div>
              </div>
              <p class="text-center text-sm text-gray-600 mt-2">กำลังรวมไฟล์... <span id="merge-progress-text">0%</span></p>
            </div>

            <!-- Result -->
            <div id="merge-result" class="hidden mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
              <h3 class="text-lg font-semibold text-green-800 mb-2">✅ รวมไฟล์สำเร็จ!</h3>
              <p class="text-green-700 mb-3" id="merge-result-text"></p>
              <button onclick="downloadMergedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                📥 ดาวน์โหลดไฟล์ที่รวมแล้ว
              </button>
            </div>
          </div>

          <!-- Control Panel -->
          <div class="lg:col-span-1">
            <div class="control-panel">
              <h3 class="text-lg font-semibold text-gray-800 mb-4">การควบคุม</h3>
              
              <!-- File Count -->
              <div class="mb-6">
                <div class="text-sm text-gray-600 mb-2">ไฟล์ที่เลือก</div>
                <div class="text-2xl font-bold text-red-600" id="file-count">0</div>
              </div>

              <!-- Order Controls -->
              <div id="order-controls" class="hidden mb-6">
                <div class="text-sm text-gray-600 mb-3">จัดเรียงไฟล์</div>
                <div class="flex flex-col gap-2">
                  <button onclick="sortFiles('name')" class="bg-gray-100 hover:bg-gray-200 px-3 py-2 rounded text-sm transition-all">
                    📝 เรียงตามชื่อ A-Z
                  </button>
                  <button onclick="sortFiles('size')" class="bg-gray-100 hover:bg-gray-200 px-3 py-2 rounded text-sm transition-all">
                    📊 เรียงตามขนาด
                  </button>
                  <button onclick="sortFiles('date')" class="bg-gray-100 hover:bg-gray-200 px-3 py-2 rounded text-sm transition-all">
                    📅 เรียงตามวันที่
                  </button>
                  <button onclick="reverseOrder()" class="bg-gray-100 hover:bg-gray-200 px-3 py-2 rounded text-sm transition-all">
                    🔄 กลับลำดับ
                  </button>
                </div>
              </div>

              <!-- Merge Options -->
              <div id="merge-options" class="hidden mb-6">
                <div class="text-sm text-gray-600 mb-3">ตัวเลือก</div>
                <div class="space-y-3">
                  <label class="flex items-center text-sm">
                    <input type="checkbox" id="add-bookmarks" class="mr-2">
                    เพิ่ม Bookmarks
                  </label>
                  <label class="flex items-center text-sm">
                    <input type="checkbox" id="preserve-links" class="mr-2" checked>
                    รักษา Links
                  </label>
                  <label class="flex items-center text-sm">
                    <input type="checkbox" id="optimize-size" class="mr-2">
                    ปรับปรุงขนาด
                  </label>
                </div>
              </div>

              <!-- Actions -->
              <div class="space-y-3">
                <button id="merge-btn" onclick="executeMerge()" class="w-full bg-red-600 text-white py-3 rounded-lg font-semibold hover:bg-red-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                  📄 รวม PDF
                </button>
                <button onclick="clearAllFiles()" class="w-full bg-gray-100 text-gray-700 py-2 rounded-lg hover:bg-gray-200 transition-all" id="clear-btn" style="display: none;">
                  🗑️ ลบทั้งหมด
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Split PDF Tool -->
    <section id="split-tool" class="hidden">
      <div class="max-w-7xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">✂️ Split PDF File</h2>
          <p class="text-gray-600">แยกไฟล์ PDF เป็นหน้าแยกหรือช่วงหน้าที่ต้องการ</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <!-- Main Content Area -->
          <div class="lg:col-span-3">
            <!-- File Upload -->
            <div id="split-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">📄</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการแยก</p>
              <input type="file" id="split-file" accept=".pdf" class="hidden">
              <button onclick="document.getElementById('split-file').click()" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>

            <!-- PDF Pages Grid -->
            <div id="pdf-pages-container" class="hidden">
              <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div id="split-file-details" class="text-blue-700 text-sm"></div>
              </div>
              
              <!-- Pages Grid -->
              <div id="pdf-pages-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 mb-6">
                <!-- PDF page thumbnails will be inserted here -->
              </div>
            </div>

            <!-- Progress -->
            <div id="split-progress" class="hidden mt-6">
              <div class="bg-white rounded-lg shadow-lg p-6">
                <div class="bg-gray-200 rounded-full h-4 overflow-hidden mb-2">
                  <div id="split-progress-bar" class="progress-bar bg-red-600 h-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <p class="text-center text-sm text-gray-600">กำลังแยกไฟล์... <span id="split-progress-text">0%</span></p>
              </div>
            </div>

            <!-- Result -->
            <div id="split-result" class="hidden mt-6">
              <div class="bg-white rounded-lg shadow-lg p-6">
                <h3 class="text-lg font-semibold text-green-800 mb-2">✅ แยกไฟล์สำเร็จ!</h3>
                <p class="text-green-700 mb-4" id="split-result-text"></p>
                <div id="split-download-links" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3"></div>
              </div>
            </div>
          </div>

          <!-- Right Sidebar: Split Options -->
          <div class="lg:col-span-1">
            <div class="bg-white rounded-lg shadow-lg p-6 sticky top-6">
              <h3 class="text-lg font-bold text-gray-800 mb-6 text-center">Split</h3>

              <!-- Split Mode Tabs -->
              <div id="split-mode-tabs" class="flex mb-6 bg-gray-100 rounded-lg p-1">
                <button id="tab-range" onclick="switchSplitTab('range')" class="flex-1 py-2 px-3 rounded-md text-gray-600 font-medium text-sm transition-all hover:bg-gray-50">
                  <div class="text-center">
                    <div class="text-lg mb-1">📊</div>
                    <div>Range</div>
                  </div>
                </button>
                <button id="tab-pages" onclick="switchSplitTab('pages')" class="flex-1 py-2 px-3 rounded-md bg-white shadow text-red-600 font-medium text-sm transition-all">
                  <div class="text-center">
                    <div class="text-lg mb-1">📄</div>
                    <div>Pages</div>
                  </div>
                </button>
                <button id="tab-size" onclick="switchSplitTab('size')" class="flex-1 py-2 px-3 rounded-md text-gray-600 font-medium text-sm transition-all hover:bg-gray-50">
                  <div class="text-center">
                    <div class="text-lg mb-1">📐</div>
                    <div>Size</div>
                  </div>
                </button>
              </div>

              <!-- Pages Tab Content (Default Active) -->
              <div id="pages-tab-content" class="space-y-4">
                <div class="mb-4">
                  <div class="text-sm font-medium text-gray-700 mb-3">Extract mode:</div>
                  <div class="space-y-2">
                    <label class="flex items-center p-3 border border-red-500 bg-red-50 rounded-lg cursor-pointer">
                      <input type="radio" name="extract-mode" value="all" class="mr-3 text-red-600" checked>
                      <div>
                        <div class="font-medium text-red-600">Extract all pages</div>
                        <div class="text-xs text-gray-500">Create separate PDF for each page</div>
                      </div>
                    </label>
                    <label class="flex items-center p-3 border border-gray-200 rounded-lg cursor-pointer hover:border-red-200">
                      <input type="radio" name="extract-mode" value="selected" class="mr-3 text-red-600">
                      <div>
                        <div class="font-medium text-gray-700">Select pages</div>
                        <div class="text-xs text-gray-500">Choose specific pages to extract</div>
                      </div>
                    </label>
                  </div>
                </div>

                <!-- Selected Pages Info -->
                <div id="selected-info" class="p-3 bg-blue-50 rounded-lg text-sm text-blue-700">
                  <div id="selected-count">Selected pages will be converted into separate PDF files.</div>
                  <div id="files-count" class="font-semibold mt-1">0 PDF will be created.</div>
                </div>

                <!-- Control Buttons -->
                <div class="space-y-2">
                  <button onclick="selectAllPages()" class="w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-all text-sm">
                    Select All Pages
                  </button>
                  <button onclick="deselectAllPages()" class="w-full py-2 px-4 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-all text-sm">
                    Deselect All Pages
                  </button>
                </div>
              </div>

              <!-- Range Tab Content -->
              <div id="range-tab-content" class="hidden space-y-4">
                <div class="mb-4">
                  <div class="text-sm font-medium text-gray-700 mb-3">Range mode:</div>
                  <div class="flex gap-2">
                    <button id="custom-ranges-btn" onclick="selectRangeMode('custom')" class="flex-1 py-2 px-3 text-sm border-2 border-red-500 bg-red-50 text-red-600 rounded-lg font-medium">
                      Custom ranges
                    </button>
                    <button id="fixed-ranges-btn" onclick="selectRangeMode('fixed')" class="flex-1 py-2 px-3 text-sm border-2 border-gray-200 text-gray-600 rounded-lg hover:border-red-200">
                      Fixed ranges
                    </button>
                  </div>
                </div>

                <div id="custom-ranges-content">
                  <div class="mb-4">
                    <div class="flex items-center justify-between mb-2">
                      <span class="text-sm font-medium text-gray-700">📊 Range 1</span>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                      <div>
                        <label class="block text-xs text-gray-500 mb-1">from page</label>
                        <input type="number" id="range1-from" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="1">
                      </div>
                      <div>
                        <label class="block text-xs text-gray-500 mb-1">to</label>
                        <input type="number" id="range1-to" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="2">
                      </div>
                    </div>
                  </div>

                  <button onclick="addRange()" class="w-full py-2 px-4 border-2 border-red-500 text-red-600 rounded-lg hover:bg-red-50 transition-all mb-4">
                    <span class="text-lg mr-1">+</span> Add Range
                  </button>

                  <div id="additional-ranges"></div>

                  <div class="mb-4">
                    <label class="flex items-center text-sm">
                      <input type="checkbox" id="merge-ranges" class="mr-2 rounded">
                      <span class="text-gray-700">Merge all ranges in one PDF file.</span>
                    </label>
                  </div>
                </div>

                <div id="fixed-ranges-content" class="hidden">
                  <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Pages per file:</label>
                    <input type="number" id="pages-per-file" class="w-full p-3 border border-gray-300 rounded-lg text-center" min="1" value="1">
                  </div>
                </div>
              </div>

              <!-- Size Tab Content -->
              <div id="size-tab-content" class="hidden space-y-4">
                <div class="mb-4">
                  <label class="block text-sm font-medium text-gray-700 mb-2">Maximum file size (MB):</label>
                  <input type="number" id="max-file-size" class="w-full p-3 border border-gray-300 rounded-lg text-center" min="1" value="10">
                </div>
                <div class="text-xs text-gray-500">
                  <p>Files will be split to keep each part under this size limit.</p>
                </div>
              </div>

              <!-- Split Button -->
              <div class="mt-6">
                <button id="split-btn" onclick="executeSplit()" class="w-full bg-red-600 text-white py-4 rounded-lg text-lg font-semibold hover:bg-red-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed shadow-lg" disabled>
                  <span class="mr-2">↗️</span>Split PDF
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Compress PDF Tool -->
    <section id="compress-tool" class="hidden">
      <div class="max-w-4xl mx-auto">
        <div class="bg-white rounded-xl shadow-lg p-8">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-gray-800 mb-2">🗜️ Compress PDF</h2>
            <p class="text-gray-600">ลดขนาดไฟล์ PDF โดยรักษาคุณภาพให้ดีที่สุด</p>
          </div>

          <!-- File Upload -->
          <div id="compress-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-6 cursor-pointer">
            <div class="animate-bounce-gentle mb-4">
              <div class="text-6xl text-gray-400">🗜️</div>
            </div>
            <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
            <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการบีบอัด</p>
            <input type="file" id="compress-file" accept=".pdf" class="hidden">
            <button onclick="document.getElementById('compress-file').click()" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-all">
              เลือกไฟล์ PDF
            </button>
          </div>

          <!-- File Info -->
          <div id="compress-file-info" class="hidden mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <h3 class="text-lg font-semibold text-blue-800 mb-2">ข้อมูลไฟล์เดิม:</h3>
            <div id="compress-original-size" class="text-blue-700"></div>
          </div>

          <!-- Compression Options -->
          <div id="compress-options" class="hidden mb-6">
            <h3 class="text-lg font-semibold mb-4">ระดับการบีบอัด:</h3>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div class="border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-green-500 transition-all" onclick="selectCompressionLevel('low')">
                <input type="radio" name="compression-level" value="low" id="compression-low" class="mb-3">
                <label for="compression-low" class="cursor-pointer">
                  <h4 class="font-semibold text-gray-800">บีบอัดน้อย</h4>
                  <p class="text-sm text-gray-600">คุณภาพสูง, ลดขนาด 10-30%</p>
                  <div class="mt-2 text-xs text-green-600">แนะนำสำหรับเอกสารสำคัญ</div>
                </label>
              </div>
              
              <div class="border-2 border-green-500 bg-green-50 rounded-lg p-4 cursor-pointer" onclick="selectCompressionLevel('medium')">
                <input type="radio" name="compression-level" value="medium" id="compression-medium" class="mb-3" checked>
                <label for="compression-medium" class="cursor-pointer">
                  <h4 class="font-semibold text-gray-800">บีบอัดกลาง</h4>
                  <p class="text-sm text-gray-600">สมดุล, ลดขนาด 30-60%</p>
                  <div class="mt-2 text-xs text-green-600">✅ แนะนำ (ความสมดุลดีที่สุด)</div>
                </label>
              </div>
              
              <div class="border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-green-500 transition-all" onclick="selectCompressionLevel('high')">
                <input type="radio" name="compression-level" value="high" id="compression-high" class="mb-3">
                <label for="compression-high" class="cursor-pointer">
                  <h4 class="font-semibold text-gray-800">บีบอัดสูง</h4>
                  <p class="text-sm text-gray-600">ขนาดเล็ก, ลดขนาด 60-80%</p>
                  <div class="mt-2 text-xs text-green-600">เหมาะสำหรับแชร์ออนไลน์</div>
                </label>
              </div>
            </div>

            <!-- Advanced Options -->
            <div class="border-t pt-4">
              <h4 class="font-semibold text-gray-800 mb-3">ตัวเลือกขั้นสูง:</h4>
              <div class="space-y-3">
                <label class="inline-flex items-center">
                  <input type="checkbox" id="optimize-images" class="mr-2" checked>
                  <span class="text-sm">ปรับปรุงคุณภาพรูปภาพ</span>
                </label>
                <label class="inline-flex items-center">
                  <input type="checkbox" id="remove-metadata" class="mr-2">
                  <span class="text-sm">ลบข้อมูล Metadata</span>
                </label>
                <label class="inline-flex items-center">
                  <input type="checkbox" id="linearize-pdf" class="mr-2">
                  <span class="text-sm">เพิ่มประสิทธิภาพการโหลดบนเว็บ</span>
                </label>
              </div>
            </div>
          </div>

          <!-- Compress Button -->
          <div class="text-center">
            <button id="compress-btn" onclick="executeCompress()" class="bg-green-600 text-white px-8 py-4 rounded-lg text-lg font-semibold hover:bg-green-700 transition-all disabled:opacity-50" disabled>
              🗜️ บีบอัด PDF
            </button>
          </div>

          <!-- Progress -->
          <div id="compress-progress" class="hidden mt-6">
            <div class="bg-gray-200 rounded-full h-4 overflow-hidden">
              <div id="compress-progress-bar" class="progress-bar bg-green-600 h-full" style="width: 0%"></div>
            </div>
            <p class="text-center text-sm text-gray-600 mt-2">กำลังบีบอัดไฟล์... <span id="compress-progress-text">0%</span></p>
          </div>

          <!-- Result -->
          <div id="compress-result" class="hidden mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
            <h3 class="text-lg font-semibold text-green-800 mb-2">✅ บีบอัดสำเร็จ!</h3>
            <div id="compress-stats" class="text-green-700 mb-3"></div>
            <button onclick="downloadCompressedFile()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
              📥 ดาวน์โหลดไฟล์ที่บีบอัดแล้ว
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- Edit PDF Tool -->
    <section id="edit-tool" class="hidden">
      <div class="max-w-7xl mx-auto">
        <div class="text-center mb-8">
          <h2 class="text-3xl font-bold text-gray-800 mb-2">✏️ Edit PDF File</h2>
          <p class="text-gray-600">แก้ไขข้อความ รูปภาพ และเพิ่มองค์ประกอบต่างๆ ใน PDF</p>
        </div>

        <div class="flex flex-col md:flex-row gap-4">
          <!-- Left Toolbar -->
          <aside class="bg-white rounded-xl shadow flex flex-col items-center py-3 gap-1 md:w-20 w-full">
            <button class="toolbar-btn" id="edit_tool_select" title="Select" onclick="setEditTool('select')">🖱️</button>
            <button class="toolbar-btn" id="edit_tool_text" title="Text" onclick="setEditTool('text')">📝</button>
            <button class="toolbar-btn" id="edit_tool_rect" title="Rectangle" onclick="setEditTool('rect')">▭</button>
            <button class="toolbar-btn" id="edit_tool_circle" title="Circle" onclick="setEditTool('circle')">◯</button>
            <button class="toolbar-btn" id="edit_tool_line" title="Line" onclick="setEditTool('line')">／</button>
            <button class="toolbar-btn" id="edit_tool_image" title="Image" onclick="setEditTool('image')">🖼️</button>
            <button class="toolbar-btn" id="edit_tool_highlight" title="Highlight" onclick="setEditTool('highlight')">🖍️</button>
            <button class="toolbar-btn" id="edit_tool_signature" title="Sign" onclick="setEditTool('signature')">✍️</button>
            <button class="toolbar-btn" id="edit_tool_undo" title="Undo" onclick="editUndo()">↩️</button>
            <button class="toolbar-btn" id="edit_tool_redo" title="Redo" onclick="editRedo()">↪️</button>
          </aside>

          <!-- Main Editor Area -->
          <div class="flex-1 flex flex-col items-center gap-3">
            <!-- Top Controls -->
            <div class="flex flex-wrap gap-2 justify-between w-full bg-white rounded-lg p-4 shadow">
              <input type="file" id="edit-file-input" accept="application/pdf" class="hidden" onchange="openEditPdf(this)">
              <button onclick="document.getElementById('edit-file-input').click()" class="bg-blue-600 text-white px-4 py-2 rounded shadow">
                📂 เปิดไฟล์ PDF
              </button>
              <button onclick="saveEditedPdf()" class="bg-green-600 text-white px-4 py-2 rounded shadow">
                💾 Save PDF
              </button>
              <div class="flex items-center gap-2">
                <button onclick="editZoom(-1)" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">-</button>
                <span id="edit-zoom-view" class="px-2">100%</span>
                <button onclick="editZoom(1)" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">+</button>
              </div>
              <div class="flex items-center gap-2">
                <button onclick="prevEditPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">⬅️</button>
                <span id="edit-page-view" class="px-2">1/1</span>
                <button onclick="nextEditPage()" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">➡️</button>
              </div>
            </div>

            <!-- Canvas Area -->
            <div class="border rounded-xl bg-white shadow mx-auto" style="overflow:auto;">
              <canvas id="edit-fabric-canvas" width="800" height="1132"></canvas>
            </div>

            <!-- File Upload Area (when no PDF loaded) -->
            <div id="edit-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-12 text-center cursor-pointer">
              <div class="animate-bounce-gentle mb-4">
                <div class="text-6xl text-gray-400">📄</div>
              </div>
              <h3 class="text-xl font-semibold text-gray-700 mb-2">ลากไฟล์ PDF หรือคลิกเพื่อเลือก</h3>
              <p class="text-gray-500 mb-4">เลือกไฟล์ PDF ที่ต้องการแก้ไข</p>
              <button onclick="document.getElementById('edit-file-input').click()" class="bg-purple-600 text-white px-6 py-3 rounded-lg hover:bg-purple-700 transition-all">
                เลือกไฟล์ PDF
              </button>
            </div>
          </div>

          <!-- Right Properties Panel -->
          <aside class="w-72 bg-white rounded-xl shadow p-4" id="edit-prop-panel">
            <span class="text-gray-400">เลือกวัตถุเพื่อดูรายละเอียด</span>
          </aside>
        </div>
      </div>
    </section>

  </main>

   <!-- Security Protection Scripts -->
  <script>
    (function() {
      'use strict';

      // แสดงข้อความแจ้งเตือนความปลอดภัย
      function showSecurityAlert(message = 'การกระทำนี้ไม่ได้รับอนุญาต!') {
        // สร้าง popup แจ้งเตือน
        const alertDiv = document.createElement('div');
        alertDiv.innerHTML = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
          ">
            <div style="
              background: white;
              padding: 30px;
              border-radius: 10px;
              text-align: center;
              box-shadow: 0 10px 30px rgba(0,0,0,0.3);
              max-width: 400px;
            ">
              <div style="color: #dc2626; font-size: 60px; margin-bottom: 20px;">🚫</div>
              <h2 style="color: #dc2626; margin: 0 0 15px 0;">ข้อความแจ้งเตือน</h2>
              <p style="color: #374151; margin: 0 0 20px 0; line-height: 1.5;">${message}</p>
              <p style="color: #6b7280; font-size: 14px; margin: 0 0 20px 0;">
                เว็บไซต์นี้ได้รับการป้องกันเพื่อความปลอดภัยของข้อมูล
              </p>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                background: #dc2626;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
              ">ตกลง</button>
            </div>
          </div>
        `;
        document.body.appendChild(alertDiv);

        // ลบแจ้งเตือนอัตโนมัติหลัง 3 วินาที
        setTimeout(() => {
          if (alertDiv.parentElement) {
            alertDiv.remove();
          }
        }, 3000);
      }

      // ป้องกันการคลิกขวา (แต่ไม่ขัดขวางการทำงานปกติ)
      document.addEventListener('contextmenu', function(e) {
        // ยกเว้นใน input และ textarea เพื่อให้ใช้เมนูคลิกขวาได้
        if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
          e.preventDefault();
          showSecurityAlert('การคลิกขวาไม่ได้รับอนุญาต');
        }
      });

      // ป้องกันปุ่มลัดบางส่วน (แต่ไม่เข้มงวดเกินไป)
      document.addEventListener('keydown', function(e) {
        // F12 - Developer Tools
        if (e.keyCode === 123) {
          e.preventDefault();
          showSecurityAlert('การใช้ Developer Tools ไม่ได้รับอนุญาต');
          return false;
        }
        
        // Ctrl+Shift+I (Developer Tools)
        if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
          e.preventDefault();
          showSecurityAlert('การใช้ Developer Tools ไม่ได้รับอนุญาต');
          return false;
        }
        
        // Ctrl+U (View Source)
        if (e.ctrlKey && e.keyCode === 85) {
          e.preventDefault();
          showSecurityAlert('การดูซอร์สโค้ดไม่ได้รับอนุญาต');
          return false;
        }
        
        // Ctrl+S (Save Page) - ยกเว้นเมื่ออยู่ใน input/textarea
        if (e.ctrlKey && e.keyCode === 83 && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
          e.preventDefault();
          showSecurityAlert('การบันทึกหน้าเว็บไม่ได้รับอนุญาต');
          return false;
        }
      });

      // ป้องกันการเลือกข้อความ (ยกเว้นใน input/textarea และ element ที่จำเป็น)
      document.addEventListener('selectstart', function(e) {
        if (!['INPUT', 'TEXTAREA', 'BUTTON'].includes(e.target.tagName) && 
            !e.target.closest('[contenteditable]') &&
            !e.target.closest('.allow-select')) {
          e.preventDefault();
          return false;
        }
      });

      // ป้องกันการลากเฉพาะรูปภาพ
      document.addEventListener('dragstart', function(e) {
        if (e.target.tagName === 'IMG') {
          e.preventDefault();
          return false;
        }
      });

      // ป้องกันการ print ด้วย CSS media query
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        @media print {
          body { display: none !important; }
          body::before { 
            content: "การพิมพ์เอกสารนี้ไม่ได้รับอนุญาต"; 
            font-size: 20px; 
            color: red; 
            display: block; 
            text-align: center; 
            margin-top: 50px; 
          }
        }
      `;
      document.head.appendChild(style);

      // ทำให้ window.showSecurityAlert สามารถเรียกใช้ได้จากภายนอก (สำหรับ debugging)
      window.showSecurityAlert = showSecurityAlert;

      console.log('🔒 Security protection activated (lite version)');

    })();
  </script>


  <!-- JavaScript -->
  <script>
    // Global Variables
    let currentTool = null;
    let processedFiles = [];
    let mergedPdfBlob = null;
    let compressedPdfBlob = null;
    let signedPdfBlob = null;
    let watermarkedPdfBlob = null;
    let rotatedPdfBlob = null;
    let protectedPdfBlob = null;
    let mergeFiles = [];
    let draggedElement = null;
    let currentSplitTab = 'pages';
    let currentRangeMode = 'custom';
    let rangeCounter = 1;
    let pdfDocument = null;
    let selectedPages = new Set();
    let totalPages = 0;

    // Preview Variables
    let signPreviewDoc = null;
    let signPreviewCurrentPage = 0;
    let signPreviewTotalPages = 0;
    let watermarkPreviewDoc = null;
    let watermarkPreviewCurrentPage = 0;
    let watermarkPreviewTotalPages = 0;
    let rotatePreviewDoc = null;
    let rotatePreviewCurrentPage = 0;
    let rotatePreviewTotalPages = 0;
    let protectPreviewDoc = null;
    let protectPreviewCurrentPage = 0;
    let protectPreviewTotalPages = 0;

    // Sign PDF Variables
    let signCanvas = null;
    let signPdfDoc = null;
    let signCurrentPage = 0;
    let signTotalPages = 0;
    let signPosition = 'bottom-right';
    let signatureImage = null;

    // Watermark Variables
    let watermarkPdfDoc = null;
    let watermarkCurrentPage = 0;
    let watermarkTotalPages = 0;
    let watermarkPosition = 'center';
    let watermarkImageData = null;

    // Rotate Variables
    let rotatePdfDoc = null;
    let rotateSelectedPages = new Set();
    let rotateAngle = 90;

    // Protect Variables
    let protectPdfDoc = null;

    // Edit PDF Variables
    const PDF_FONTS = [
      "Sarabun","Prompt","Kanit","Mitr","Maitree","Pridi","Sriracha","Srisakdi","Taviraj","Niramit","Chonburi","Charmonman","Charm","Pattaya","Bai Jamjuree","Mali","Sura","Noto Sans Thai","Noto Serif Thai",
      "Arial","Times New Roman","Helvetica","Courier New","Georgia","Verdana","Trebuchet MS","Comic Sans MS","Impact","Lucida Console"
    ];
    let editFabricCanvas = null;
    let editTool = 'select';
    let editPdfPages = [];
    let editPageNum = 0;
    let editScale = 1;
    let editPdfLoaded = false;
    let editHistory = [];
    let editRedoStack = [];
    let maxEditHistory = 50;
    let editPdfW = 800;
    let editPdfH = 1132;
    let editPdfImages = [];
    let editIsDrawing = false;
    let editStartX = 0;
    let editStartY = 0;
    let editCurrentObject = null;

    // Initialize PDF.js
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    // Preview Functions
    async function generatePdfPreview(pdfBlob, canvasId, pageInfoId, currentPage = 0) {
      try {
        if (!pdfBlob || typeof pdfjsLib === 'undefined') return;
        
        const arrayBuffer = await pdfBlob.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(currentPage + 1);
        
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const context = canvas.getContext('2d');
        const viewport = page.getViewport({ scale: 0.8 });
        
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        
        const pageInfo = document.getElementById(pageInfoId);
        if (pageInfo) {
          pageInfo.textContent = `${currentPage + 1}/${pdf.numPages}`;
        }
        
        return pdf.numPages;
      } catch (error) {
        console.error('Error generating preview:', error);
        return 0;
      }
    }

    // PDF Thumbnail Generation
    async function generatePdfThumbnail(file) {
      try {
        if (typeof pdfjsLib === 'undefined') {
          console.error('PDF.js not loaded');
          return null;
        }
        
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(1);
        
        const viewport = page.getViewport({ scale: 0.5 });
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        await page.render({
          canvasContext: context,
          viewport: viewport
        }).promise;
        
        return canvas.toDataURL();
      } catch (error) {
        console.error('Error generating thumbnail:', error);
        return null;
      }
    }

    // Merge PDF Functions
    function setupMergeListeners() {
      const fileInput = document.getElementById('merge-files');
      const dropZone = document.getElementById('merge-drop-zone');
      const mergeArea = document.getElementById('merge-area');

      if (fileInput) {
        fileInput.addEventListener('change', handleMergeFiles);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
      }

      // Merge area drag and drop
      if (mergeArea) {
        mergeArea.addEventListener('dragover', handleDragOver);
        mergeArea.addEventListener('dragleave', handleDragLeave);
        mergeArea.addEventListener('drop', handleDrop);
      }
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('dragover');
    }

    function handleDragLeave(e) {
      e.currentTarget.classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('dragover');
      
      const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
      if (files.length > 0) {
        addFilesToMerge(files);
      }
    }

    function handleMergeFiles(e) {
      const files = Array.from(e.target.files);
      addFilesToMerge(files);
    }

    async function addFilesToMerge(files) {
      for (const file of files) {
        const thumbnail = await generatePdfThumbnail(file);
        mergeFiles.push({
          file: file,
          id: Date.now() + Math.random(),
          thumbnail: thumbnail,
          name: file.name,
          size: file.size,
          lastModified: file.lastModified
        });
      }
      
      updateMergeUI();
    }

    async function updateMergeUI() {
      const emptyState = document.getElementById('empty-state');
      const pdfGrid = document.getElementById('pdf-grid');
      const mergeArea = document.getElementById('merge-area');
      const fileCount = document.getElementById('file-count');
      const orderControls = document.getElementById('order-controls');
      const mergeOptions = document.getElementById('merge-options');
      const mergeBtn = document.getElementById('merge-btn');
      const clearBtn = document.getElementById('clear-btn');

      if (mergeFiles.length === 0) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (pdfGrid) pdfGrid.classList.add('hidden');
        if (orderControls) orderControls.classList.add('hidden');
        if (mergeOptions) mergeOptions.classList.add('hidden');
        if (clearBtn) clearBtn.style.display = 'none';
        if (mergeArea) mergeArea.classList.remove('has-files');
        if (mergeBtn) mergeBtn.disabled = true;
      } else {
        if (emptyState) emptyState.classList.add('hidden');
        if (pdfGrid) pdfGrid.classList.remove('hidden');
        if (orderControls) orderControls.classList.remove('hidden');
        if (mergeOptions) mergeOptions.classList.remove('hidden');
        if (clearBtn) clearBtn.style.display = 'block';
        if (mergeArea) mergeArea.classList.add('has-files');
        if (mergeBtn) mergeBtn.disabled = mergeFiles.length < 2;
      }

      if (fileCount) fileCount.textContent = mergeFiles.length;
      
      // Update PDF grid
      if (pdfGrid) {
        pdfGrid.innerHTML = '';
        mergeFiles.forEach((fileData, index) => {
          const card = createPdfCard(fileData, index);
          pdfGrid.appendChild(card);
        });
      }
    }

    function createPdfCard(fileData, index) {
      const card = document.createElement('div');
      card.className = 'pdf-card';
      card.draggable = true;
      card.dataset.index = index;
      
      card.innerHTML = `
        <div class="page-number">${index + 1}</div>
        <div class="remove-btn" onclick="removeFile(${index})">✕</div>
        <div class="pdf-thumbnail">
          ${fileData.thumbnail ? 
            `<img src="${fileData.thumbnail}" alt="PDF thumbnail" class="w-full h-full object-cover rounded-t-lg">` :
            `<div class="text-4xl text-gray-400">📄</div>`
          }
        </div>
        <div class="p-4">
          <h4 class="font-medium text-gray-800 text-sm mb-1 truncate" title="${fileData.name}">
            ${fileData.name}
          </h4>
          <p class="text-xs text-gray-500">
            ${(fileData.size / 1024 / 1024).toFixed(2)} MB
          </p>
        </div>
      `;

      // Drag and drop events
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragover', handleCardDragOver);
      card.addEventListener('dragenter', handleCardDragEnter);
      card.addEventListener('dragleave', handleCardDragLeave);
      card.addEventListener('drop', handleCardDrop);
      card.addEventListener('dragend', handleDragEnd);

      return card;
    }

    // Drag and Drop for reordering
    function handleDragStart(e) {
      draggedElement = e.currentTarget;
      e.currentTarget.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', e.currentTarget.outerHTML);
    }

    function handleCardDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }

    function handleCardDragEnter(e) {
      e.preventDefault();
      if (e.currentTarget !== draggedElement) {
        e.currentTarget.classList.add('drag-over');
      }
    }

    function handleCardDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function handleCardDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      
      if (e.currentTarget !== draggedElement) {
        const draggedIndex = parseInt(draggedElement.dataset.index);
        const targetIndex = parseInt(e.currentTarget.dataset.index);
        
        // Reorder files array
        const draggedFile = mergeFiles[draggedIndex];
        mergeFiles.splice(draggedIndex, 1);
        mergeFiles.splice(targetIndex, 0, draggedFile);
        
        updateMergeUI();
      }
    }

    function handleDragEnd(e) {
      e.currentTarget.classList.remove('dragging');
      document.querySelectorAll('.pdf-card').forEach(card => {
        card.classList.remove('drag-over');
      });
      draggedElement = null;
    }

    function removeFile(index) {
      mergeFiles.splice(index, 1);
      updateMergeUI();
    }

    function clearAllFiles() {
      mergeFiles = [];
      const mergeFilesInput = document.getElementById('merge-files');
      if (mergeFilesInput) mergeFilesInput.value = '';
      updateMergeUI();
    }

    function sortFiles(method) {
      switch(method) {
        case 'name':
          mergeFiles.sort((a, b) => a.name.localeCompare(b.name));
          break;
        case 'size':
          mergeFiles.sort((a, b) => a.size - b.size);
          break;
        case 'date':
          mergeFiles.sort((a, b) => a.lastModified - b.lastModified);
          break;
      }
      updateMergeUI();
    }

    function reverseOrder() {
      mergeFiles.reverse();
      updateMergeUI();
    }

    async function executeMerge() {
      if (mergeFiles.length < 2) {
        alert('กรุณาเลือกไฟล์ PDF อย่างน้อย 2 ไฟล์');
        return;
      }

      const progress = document.getElementById('merge-progress');
      const progressBar = document.getElementById('merge-progress-bar');
      const progressText = document.getElementById('merge-progress-text');
      const result = document.getElementById('merge-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        if (typeof PDFLib === 'undefined') {
          alert('PDF library not loaded');
          return;
        }
        
        const mergedPdf = await PDFLib.PDFDocument.create();
        
        for (let i = 0; i < mergeFiles.length; i++) {
          const fileData = mergeFiles[i];
          if (progressText) progressText.textContent = `กำลังประมวลผล ${fileData.name}... ${Math.round((i / mergeFiles.length) * 100)}%`;
          if (progressBar) progressBar.style.width = `${(i / mergeFiles.length) * 90}%`;
          
          const arrayBuffer = await fileData.file.arrayBuffer();
          const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
          const pages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
          
          pages.forEach(page => mergedPdf.addPage(page));
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์ใหม่...';
        if (progressBar) progressBar.style.width = '95%';
        
        const pdfBytes = await mergedPdf.save();
        mergedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = 'เสร็จสิ้น!';
        
        setTimeout(() => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          const totalSize = mergeFiles.reduce((sum, fileData) => sum + fileData.size, 0);
          const mergeResultText = document.getElementById('merge-result-text');
          if (mergeResultText) {
            mergeResultText.textContent = 
              `รวม ${mergeFiles.length} ไฟล์เรียบร้อย ขนาดไฟล์: ${(mergedPdfBlob.size / 1024 / 1024).toFixed(2)} MB (เดิม: ${(totalSize / 1024 / 1024).toFixed(2)} MB)`;
          }
        }, 1000);
        
      } catch (error) {
        console.error('Error merging PDFs:', error);
        alert('เกิดข้อผิดพลาดในการรวม PDF: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function downloadMergedFile() {
      if (mergedPdfBlob) {
        const url = URL.createObjectURL(mergedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `merged-pdf-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Split PDF Functions
    function switchSplitTab(tab) {
      console.log('Switching to tab:', tab);
      currentSplitTab = tab;
      
      // Update tab buttons
      const tabs = ['range', 'pages', 'size'];
      tabs.forEach(tabName => {
        const tabBtn = document.getElementById(`tab-${tabName}`);
        if (tabBtn) {
          if (tabName === tab) {
            tabBtn.className = 'flex-1 py-2 px-3 rounded-md bg-white shadow text-red-600 font-medium text-sm transition-all';
          } else {
            tabBtn.className = 'flex-1 py-2 px-3 rounded-md text-gray-600 font-medium text-sm transition-all hover:bg-gray-50';
          }
        }
      });
      
      // Show/hide content
      const rangeContent = document.getElementById('range-tab-content');
      const pagesContent = document.getElementById('pages-tab-content');
      const sizeContent = document.getElementById('size-tab-content');
      
      if (rangeContent) rangeContent.style.display = tab === 'range' ? 'block' : 'none';
      if (pagesContent) pagesContent.style.display = tab === 'pages' ? 'block' : 'none';
      if (sizeContent) sizeContent.style.display = tab === 'size' ? 'block' : 'none';
    }

    async function handleSplitFile(e) {
      const file = e.target.files[0];
      const pagesContainer = document.getElementById('pdf-pages-container');
      const splitBtn = document.getElementById('split-btn');
      
      if (file) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          if (typeof PDFLib !== 'undefined') {
            pdfDocument = await PDFLib.PDFDocument.load(arrayBuffer);
            totalPages = pdfDocument.getPageCount();
          } else {
            console.error('PDFLib not loaded');
            alert('PDF library not loaded');
            return;
          }
          
          // อัปเดตข้อมูลไฟล์
          const fileDetails = document.getElementById('split-file-details');
          if (fileDetails) {
            fileDetails.innerHTML = `
              <strong>${file.name}</strong> • ${(file.size / 1024 / 1024).toFixed(2)} MB • ${totalPages} หน้า
            `;
          }
          
          // Update range inputs max values
          const range1To = document.getElementById('range1-to');
          const range1From = document.getElementById('range1-from');
          if (range1To) {
            range1To.max = totalPages;
            range1To.value = Math.min(2, totalPages);
          }
          if (range1From) {
            range1From.max = totalPages;
          }
          
          if (pagesContainer) pagesContainer.classList.remove('hidden');
          if (splitBtn) splitBtn.disabled = false;
          
          // สร้าง PDF page thumbnails
          await generatePdfPageThumbnails(file);
          
          // เริ่มต้นด้วยการเลือกทุกหน้า
          selectAllPages();
          
        } catch (error) {
          console.error('Error reading PDF:', error);
          alert('ไม่สามารถอ่านไฟล์ PDF ได้');
        }
      } else {
        if (pagesContainer) pagesContainer.classList.add('hidden');
        if (splitBtn) splitBtn.disabled = true;
      }
    }

    async function generatePdfPageThumbnails(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        if (typeof pdfjsLib === 'undefined') {
          console.error('PDF.js not loaded');
          return;
        }
        
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const pagesGrid = document.getElementById('pdf-pages-grid');
        
        if (pagesGrid) {
          pagesGrid.innerHTML = '';
        }
        selectedPages.clear();
        
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 0.5 });
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          
          await page.render({
            canvasContext: context,
            viewport: viewport
          }).promise;
          
          // สร้าง page item
          const pageItem = document.createElement('div');
          pageItem.className = 'pdf-page-item';
          pageItem.dataset.pageNumber = pageNum;
          pageItem.onclick = () => togglePageSelection(pageNum);
          
          pageItem.innerHTML = `
            <canvas class="pdf-page-canvas"></canvas>
            <div class="page-number-badge">${pageNum}</div>
            <div class="selection-indicator"></div>
          `;
          
          // คัดลอก canvas
          const displayCanvas = pageItem.querySelector('.pdf-page-canvas');
          displayCanvas.width = canvas.width;
          displayCanvas.height = canvas.height;
          const displayContext = displayCanvas.getContext('2d');
          displayContext.drawImage(canvas, 0, 0);
          
          if (pagesGrid) {
            pagesGrid.appendChild(pageItem);
          }
        }
        
      } catch (error) {
        console.error('Error generating thumbnails:', error);
      }
    }

    function togglePageSelection(pageNumber) {
      const pageItem = document.querySelector(`[data-page-number="${pageNumber}"]`);
      
      if (selectedPages.has(pageNumber)) {
        selectedPages.delete(pageNumber);
        if (pageItem) pageItem.classList.remove('selected');
      } else {
        selectedPages.add(pageNumber);
        if (pageItem) pageItem.classList.add('selected');
      }
      
      updateSelectedInfo();
      updateExtractMode();
    }

    function selectAllPages() {
      selectedPages.clear();
      for (let i = 1; i <= totalPages; i++) {
        selectedPages.add(i);
      }
      
      document.querySelectorAll('.pdf-page-item').forEach(item => {
        item.classList.add('selected');
      });
      
      updateSelectedInfo();
      updateExtractMode();
    }

    function deselectAllPages() {
      selectedPages.clear();
      
      document.querySelectorAll('.pdf-page-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      updateSelectedInfo();
      updateExtractMode();
    }

    function updateSelectedInfo() {
      const selectedCount = selectedPages.size;
      const selectedCountEl = document.getElementById('selected-count');
      const filesCountEl = document.getElementById('files-count');
      
      if (selectedCountEl && filesCountEl) {
        if (selectedCount === 0) {
          selectedCountEl.textContent = 'No pages selected.';
          filesCountEl.textContent = '0 PDF will be created.';
        } else if (selectedCount === totalPages) {
          selectedCountEl.textContent = 'All pages selected. Each page will be converted into separate PDF files.';
          filesCountEl.textContent = `${selectedCount} PDF will be created.`;
        } else {
          selectedCountEl.textContent = `${selectedCount} pages selected. Each page will be converted into separate PDF files.`;
          filesCountEl.textContent = `${selectedCount} PDF will be created.`;
        }
      }
    }

    function updateExtractMode() {
      const extractModeRadios = document.querySelectorAll('input[name="extract-mode"]');
      if (extractModeRadios.length >= 2) {
        const allRadio = extractModeRadios[0];
        const selectedRadio = extractModeRadios[1];
        
        if (selectedPages.size === totalPages) {
          allRadio.checked = true;
          allRadio.parentElement.classList.add('active');
          selectedRadio.parentElement.classList.remove('active');
        } else {
          selectedRadio.checked = true;
          selectedRadio.parentElement.classList.add('active');
          allRadio.parentElement.classList.remove('active');
        }
      }
    }

    // Event listeners สำหรับ extract mode
    function setupExtractModeListeners() {
      const extractModeRadios = document.querySelectorAll('input[name="extract-mode"]');
      
      extractModeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          // อัปเดต visual state
          extractModeRadios.forEach(r => {
            r.parentElement.classList.remove('active');
          });
          e.target.parentElement.classList.add('active');
          
          // อัปเดตการเลือกหน้า
          if (e.target.value === 'all') {
            selectAllPages();
          }
        });
      });
    }

    function selectRangeMode(mode) {
      console.log('Selecting range mode:', mode);
      currentRangeMode = mode;
      
      // Update buttons
      const customBtn = document.getElementById('custom-ranges-btn');
      const fixedBtn = document.getElementById('fixed-ranges-btn');
      
      if (customBtn && fixedBtn) {
        if (mode === 'custom') {
          customBtn.className = 'flex-1 py-2 px-3 text-sm border-2 border-red-500 bg-red-50 text-red-600 rounded-lg font-medium';
          fixedBtn.className = 'flex-1 py-2 px-3 text-sm border-2 border-gray-200 text-gray-600 rounded-lg hover:border-red-200';
        } else {
          customBtn.className = 'flex-1 py-2 px-3 text-sm border-2 border-gray-200 text-gray-600 rounded-lg hover:border-red-200';
          fixedBtn.className = 'flex-1 py-2 px-3 text-sm border-2 border-red-500 bg-red-50 text-red-600 rounded-lg font-medium';
        }
      }
      
      // Show/hide content
      const customContent = document.getElementById('custom-ranges-content');
      const fixedContent = document.getElementById('fixed-ranges-content');
      
      if (customContent) customContent.style.display = mode === 'custom' ? 'block' : 'none';
      if (fixedContent) fixedContent.style.display = mode === 'fixed' ? 'block' : 'none';
    }

    function addRange() {
      console.log('Adding range:', rangeCounter + 1);
      rangeCounter++;
      const container = document.getElementById('additional-ranges');
      
      if (container) {
        const rangeDiv = document.createElement('div');
        rangeDiv.className = 'mb-4';
        rangeDiv.id = `range-${rangeCounter}`;
        rangeDiv.innerHTML = `
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium text-gray-700">📊 Range ${rangeCounter}</span>
            <button onclick="removeRange(${rangeCounter})" class="text-red-500 hover:text-red-700 text-sm">✕</button>
          </div>
          <div class="grid grid-cols-2 gap-2 mb-2">
            <div>
              <label class="block text-xs text-gray-500 mb-1">from page</label>
              <input type="number" id="range${rangeCounter}-from" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="1">
            </div>
            <div>
              <label class="block text-xs text-gray-500 mb-1">to</label>
              <input type="number" id="range${rangeCounter}-to" class="w-full p-2 border border-gray-300 rounded text-center" min="1" value="2">
            </div>
          </div>
        `;
        
        container.appendChild(rangeDiv);
      }
    }

    function removeRange(rangeNum) {
      console.log('Removing range:', rangeNum);
      const element = document.getElementById(`range-${rangeNum}`);
      if (element) {
        element.remove();
      }
    }

    function setupSplitListeners() {
      const fileInput = document.getElementById('split-file');
      const dropZone = document.getElementById('split-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleSplitFile);
      }
      
      if (dropZone) {
        // Drop zone setup
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleSplitFile({ target: fileInput });
          }
        });
      }
      
      // Setup extract mode listeners
      setupExtractModeListeners();
    }

    async function executeSplit() {
      if (!pdfDocument) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      const progress = document.getElementById('split-progress');
      const progressBar = document.getElementById('split-progress-bar');
      const progressText = document.getElementById('split-progress-text');
      const result = document.getElementById('split-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        let splitTasks = [];
        
        switch(currentSplitTab) {
          case 'pages':
            // แยกตามหน้าที่เลือก
            if (selectedPages.size === 0) {
              alert('กรุณาเลือกหน้าที่ต้องการแยก');
              if (progress) progress.classList.add('hidden');
              return;
            }
            
            const selectedPagesArray = Array.from(selectedPages).sort((a, b) => a - b);
            selectedPagesArray.forEach(pageNum => {
              splitTasks.push({
                pages: [pageNum - 1], // PDF-lib ใช้ 0-based index
                filename: `page-${pageNum}.pdf`
              });
            });
            break;
            
          case 'range':
            if (currentRangeMode === 'custom') {
              // Handle custom ranges
              const ranges = getAllRanges();
              const mergeRangesEl = document.getElementById('merge-ranges');
              const mergeAll = mergeRangesEl ? mergeRangesEl.checked : false;
              
              if (mergeAll) {
                // Merge all ranges into one file
                const allPages = [];
                ranges.forEach(range => {
                  for (let i = range.from - 1; i <= range.to - 1; i++) {
                    if (i >= 0 && i < totalPages) {
                      allPages.push(i);
                    }
                  }
                });
                
                if (allPages.length > 0) {
                  splitTasks.push({
                    pages: allPages,
                    filename: `selected-ranges.pdf`
                  });
                }
              } else {
                // Create separate files for each range
                ranges.forEach((range, index) => {
                  const pages = [];
                  for (let i = range.from - 1; i <= range.to - 1; i++) {
                    if (i >= 0 && i < totalPages) {
                      pages.push(i);
                    }
                  }
                  
                  if (pages.length > 0) {
                    splitTasks.push({
                      pages: pages,
                      filename: `range-${range.from}-to-${range.to}.pdf`
                    });
                  }
                });
              }
            } else {
              // Fixed ranges
              const pagesPerFileEl = document.getElementById('pages-per-file');
              const pagesPerFile = pagesPerFileEl ? parseInt(pagesPerFileEl.value) || 1 : 1;
              for (let i = 0; i < totalPages; i += pagesPerFile) {
                const pages = Array.from(
                  {length: Math.min(pagesPerFile, totalPages - i)}, 
                  (_, j) => i + j
                );
                splitTasks.push({
                  pages: pages,
                  filename: `part-${Math.floor(i / pagesPerFile) + 1}.pdf`
                });
              }
            }
            break;
            
          case 'size':
            // Split by file size (simplified approach)
            const maxFileSizeEl = document.getElementById('max-file-size');
            const targetSizeMB = maxFileSizeEl ? parseInt(maxFileSizeEl.value) || 10 : 10;
            const fileInput = document.getElementById('split-file');
            const file = fileInput ? fileInput.files[0] : null;
            if (file) {
              const avgPageSize = file.size / totalPages;
              const pagesPerFile = Math.max(1, Math.floor((targetSizeMB * 1024 * 1024) / avgPageSize));
              
              for (let i = 0; i < totalPages; i += pagesPerFile) {
                const pages = Array.from(
                  {length: Math.min(pagesPerFile, totalPages - i)}, 
                  (_, j) => i + j
                );
                splitTasks.push({
                  pages: pages,
                  filename: `part-${Math.floor(i / pagesPerFile) + 1}.pdf`
                });
              }
            }
            break;
        }
        
        if (splitTasks.length === 0) {
          alert('ไม่มีหน้าที่จะแยก กรุณาตรวจสอบการตั้งค่า');
          if (progress) progress.classList.add('hidden');
          return;
        }
        
        processedFiles = [];
        
        for (let i = 0; i < splitTasks.length; i++) {
          const task = splitTasks[i];
          if (progressText) progressText.textContent = `กำลังสร้างไฟล์ ${i + 1} จาก ${splitTasks.length}...`;
          if (progressBar) progressBar.style.width = `${((i + 1) / splitTasks.length) * 100}%`;
          
          if (typeof PDFLib !== 'undefined') {
            const newPdf = await PDFLib.PDFDocument.create();
            const pages = await newPdf.copyPages(pdfDocument, task.pages);
            pages.forEach(page => newPdf.addPage(page));
            
            const pdfBytes = await newPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            
            processedFiles.push({
              blob: blob,
              filename: task.filename
            });
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        setTimeout(() => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          const resultText = document.getElementById('split-result-text');
          if (resultText) {
            resultText.textContent = `แยกไฟล์เรียบร้อย ได้ ${processedFiles.length} ไฟล์`;
          }
          
          const downloadLinks = document.getElementById('split-download-links');
          if (downloadLinks) {
            downloadLinks.innerHTML = '';
            
            processedFiles.forEach((file, index) => {
              const link = document.createElement('button');
              link.className = 'bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 text-sm flex items-center justify-center gap-2';
              link.innerHTML = `<span>📥</span><span class="truncate">${file.filename}</span>`;
              link.onclick = () => downloadSplitFile(index);
              downloadLinks.appendChild(link);
            });
            
            // Add download all button if multiple files
            if (processedFiles.length > 1) {
              const downloadAll = document.createElement('button');
              downloadAll.className = 'bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 text-sm col-span-full';
              downloadAll.innerHTML = '<span class="mr-2">📥</span>ดาวน์โหลดทั้งหมด';
              downloadAll.onclick = downloadAllSplitFiles;
              downloadLinks.appendChild(downloadAll);
            }
          }
          
        }, 500);
        
      } catch (error) {
        console.error('Error splitting PDF:', error);
        alert('เกิดข้อผิดพลาดในการแยก PDF: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function getAllRanges() {
      const ranges = [];
      
      // Get Range 1
      const from1El = document.getElementById('range1-from');
      const to1El = document.getElementById('range1-to');
      if (from1El && to1El) {
        const from1 = parseInt(from1El.value);
        const to1 = parseInt(to1El.value);
        if (from1 && to1 && from1 <= to1) {
          ranges.push({ from: from1, to: to1 });
        }
      }
      
      // Get additional ranges
      for (let i = 2; i <= rangeCounter; i++) {
        const fromEl = document.getElementById(`range${i}-from`);
        const toEl = document.getElementById(`range${i}-to`);
        if (fromEl && toEl) {
          const from = parseInt(fromEl.value);
          const to = parseInt(toEl.value);
          if (from && to && from <= to) {
            ranges.push({ from: from, to: to });
          }
        }
      }
      
      return ranges;
    }

    function downloadSplitFile(index) {
      if (processedFiles[index]) {
        const file = processedFiles[index];
        const url = URL.createObjectURL(file.blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.filename;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    function downloadAllSplitFiles() {
      processedFiles.forEach((file, index) => {
        setTimeout(() => downloadSplitFile(index), index * 200);
      });
    }

    // Compress PDF Functions
    function setupCompressListeners() {
      const fileInput = document.getElementById('compress-file');
      const dropZone = document.getElementById('compress-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleCompressFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleCompressFile({ target: fileInput });
          }
        });
      }
    }

    async function handleCompressFile(e) {
      const file = e.target.files[0];
      const fileInfo = document.getElementById('compress-file-info');
      const options = document.getElementById('compress-options');
      const compressBtn = document.getElementById('compress-btn');
      
      if (file) {
        const sizeMB = (file.size / 1024 / 1024).toFixed(2);
        const compressOriginalSize = document.getElementById('compress-original-size');
        if (compressOriginalSize) {
          compressOriginalSize.innerHTML = `
            <div class="grid grid-cols-2 gap-4">
              <div>ชื่อไฟล์: <strong>${file.name}</strong></div>
              <div>ขนาดไฟล์: <strong>${sizeMB} MB</strong></div>
            </div>
          `;
        }
        
        if (fileInfo) fileInfo.classList.remove('hidden');
        if (options) options.classList.remove('hidden');
        if (compressBtn) compressBtn.disabled = false;
      } else {
        if (fileInfo) fileInfo.classList.add('hidden');
        if (options) options.classList.add('hidden');
        if (compressBtn) compressBtn.disabled = true;
      }
    }

    function selectCompressionLevel(level) {
      document.querySelectorAll('[onclick^="selectCompressionLevel"]').forEach(div => {
        div.className = div.className.replace('border-green-500 bg-green-50', 'border-gray-200');
      });
      
      if (event && event.currentTarget) {
        event.currentTarget.className = event.currentTarget.className.replace('border-gray-200', 'border-green-500 bg-green-50');
      }
      
      const levelCheckbox = document.getElementById(`compression-${level}`);
      if (levelCheckbox) levelCheckbox.checked = true;
    }

    async function executeCompress() {
      const fileInput = document.getElementById('compress-file');
      const file = fileInput ? fileInput.files[0] : null;
      const levelEl = document.querySelector('input[name="compression-level"]:checked');
      const level = levelEl ? levelEl.value : 'medium';
      const progress = document.getElementById('compress-progress');
      const progressBar = document.getElementById('compress-progress-bar');
      const progressText = document.getElementById('compress-progress-text');
      const result = document.getElementById('compress-result');
      
      if (!file) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        if (progressText) progressText.textContent = 'กำลังวิเคราะห์ไฟล์...';
        if (progressBar) progressBar.style.width = '20%';
        
        if (typeof PDFLib === 'undefined') {
          alert('PDF library not loaded');
          return;
        }
        
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
        
        if (progressText) progressText.textContent = 'กำลังบีบอัดไฟล์...';
        if (progressBar) progressBar.style.width = '60%';
        
        // Compression settings based on level
        let compressionOptions = {
          useObjectStreams: true,
          addDefaultPage: false
        };
        
        switch(level) {
          case 'low':
            compressionOptions.objectsPerTick = 20;
            break;
          case 'medium':
            compressionOptions.objectsPerTick = 50;
            break;
          case 'high':
            compressionOptions.objectsPerTick = 100;
            break;
        }
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์ใหม่...';
        if (progressBar) progressBar.style.width = '90%';
        
        const pdfBytes = await pdf.save(compressionOptions);
        compressedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = 'เสร็จสิ้น!';
        
        const originalSize = file.size;
        const compressedSize = compressedPdfBlob.size;
        const compressionRatio = ((originalSize - compressedSize) / originalSize * 100);
        
        setTimeout(() => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          const compressStats = document.getElementById('compress-stats');
          if (compressStats) {
            compressStats.innerHTML = `
              <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                <div>
                  <div class="text-lg font-semibold">${(originalSize / 1024 / 1024).toFixed(2)} MB</div>
                  <div class="text-sm">ขนาดเดิม</div>
                </div>
                <div>
                  <div class="text-lg font-semibold">${(compressedSize / 1024 / 1024).toFixed(2)} MB</div>
                  <div class="text-sm">ขนาดใหม่</div>
                </div>
                <div>
                  <div class="text-lg font-semibold text-green-600">${compressionRatio > 0 ? compressionRatio.toFixed(1) : 0}%</div>
                  <div class="text-sm">ลดลง</div>
                </div>
              </div>
            `;
          }
        }, 500);
        
      } catch (error) {
        console.error('Error compressing PDF:', error);
        alert('เกิดข้อผิดพลาดในการบีบอัด PDF: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function downloadCompressedFile() {
      if (compressedPdfBlob) {
        const url = URL.createObjectURL(compressedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `compressed-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Edit PDF Functions
    function initializeEditTool() {
      if (!editFabricCanvas) {
        editFabricCanvas = new fabric.Canvas('edit-fabric-canvas', { 
          backgroundColor: null, 
          preserveObjectStacking: true, 
          selection: true 
        });
        
        // Setup edit listeners
        setupEditListeners();
        setEditTool('select');
        
        // Save initial state
        saveEditState();
      }
    }

    function setupEditListeners() {
      const fileInput = document.getElementById('edit-file-input');
      const dropZone = document.getElementById('edit-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleEditFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleEditFile({ target: fileInput });
          }
        });
      }

      // Event listeners for free drawing (highlight & signature)
      editFabricCanvas.on('path:created', function(e) {
        saveEditState();
        setTimeout(() => {
          setEditTool('select');
          editFabricCanvas.setActiveObject(e.path);
          editFabricCanvas.requestRenderAll();
        }, 100);
      });

      // Mouse events for creating objects
      editFabricCanvas.on('mouse:down', function(opt) {
        if (editTool === 'select' || editTool === 'highlight' || editTool === 'signature') return;
        
        editIsDrawing = true;
        editStartX = opt.pointer.x;
        editStartY = opt.pointer.y;
        
        if (editTool === 'text') {
          editCurrentObject = new fabric.Textbox('ข้อความ', { 
            left: editStartX, 
            top: editStartY, 
            width: 0,
            fontFamily: 'Sarabun', 
            fontSize: 32, 
            fill: '#000',
            backgroundColor: 'rgba(255,255,255,0.8)',
            borderColor: '#333',
            cornerColor: '#333'
          });
          editFabricCanvas.add(editCurrentObject);
          editFabricCanvas.requestRenderAll();
        } else if (editTool === 'image') {
          let input = document.createElement('input');
          input.type = 'file';
          input.accept = 'image/*';
          input.onchange = e => {
            let reader = new FileReader();
            reader.onload = ev => fabric.Image.fromURL(ev.target.result, img => {
              editFabricCanvas.add(img.set({ 
                left: editStartX, 
                top: editStartY, 
                scaleX: 0.3, 
                scaleY: 0.3 
              })).setActiveObject(img);
              saveEditState();
              setEditTool('select');
            });
            reader.readAsDataURL(e.target.files[0]);
          };
          input.click();
          editIsDrawing = false;
        } else {
          if (editTool === 'rect') {
            editCurrentObject = new fabric.Rect({ 
              left: editStartX, 
              top: editStartY, 
              width: 0, 
              height: 0, 
              fill: 'rgba(255,255,0,0.18)', 
              stroke: '#333', 
              strokeWidth: 2 
            });
          } else if (editTool === 'circle') {
            editCurrentObject = new fabric.Circle({ 
              left: editStartX, 
              top: editStartY, 
              radius: 0, 
              fill: 'rgba(0,255,255,0.16)', 
              stroke: '#222', 
              strokeWidth: 2 
            });
          } else if (editTool === 'line') {
            editCurrentObject = new fabric.Line([editStartX, editStartY, editStartX, editStartY], { 
              stroke: '#333', 
              strokeWidth: 3 
            });
          }
          
          if (editCurrentObject) {
            editFabricCanvas.add(editCurrentObject);
            editFabricCanvas.requestRenderAll();
          }
        }
      });

      editFabricCanvas.on('mouse:move', function(opt) {
        if (!editIsDrawing || !editCurrentObject) return;
        
        let pointer = opt.pointer;
        let width = pointer.x - editStartX;
        let height = pointer.y - editStartY;
        
        if (editTool === 'text') {
          editCurrentObject.set({
            width: Math.abs(width) > 50 ? Math.abs(width) : 50,
            left: width > 0 ? editStartX : pointer.x,
            top: height > 0 ? editStartY : pointer.y
          });
        } else if (editTool === 'rect') {
          editCurrentObject.set({
            width: Math.abs(width),
            height: Math.abs(height),
            left: width > 0 ? editStartX : pointer.x,
            top: height > 0 ? editStartY : pointer.y
          });
        } else if (editTool === 'circle') {
          let radius = Math.sqrt(width * width + height * height) / 2;
          editCurrentObject.set({
            radius: radius,
            left: editStartX - radius,
            top: editStartY - radius
          });
        } else if (editTool === 'line') {
          editCurrentObject.set({
            x2: pointer.x,
            y2: pointer.y
          });
        }
        
        editFabricCanvas.requestRenderAll();
      });

      editFabricCanvas.on('mouse:up', function(opt) {
        if (!editIsDrawing) return;
        
        editIsDrawing = false;
        
        if (editCurrentObject) {
          let shouldRemove = false;
          
          if (editTool === 'text' && editCurrentObject.width < 50) {
            shouldRemove = true;
          } else if (editTool === 'rect' && (editCurrentObject.width < 5 || editCurrentObject.height < 5)) {
            shouldRemove = true;
          } else if (editTool === 'circle' && editCurrentObject.radius < 3) {
            shouldRemove = true;
          } else if (editTool === 'line') {
            let distance = Math.sqrt(Math.pow(editCurrentObject.x2 - editCurrentObject.x1, 2) + Math.pow(editCurrentObject.y2 - editCurrentObject.y1, 2));
            if (distance < 5) shouldRemove = true;
          }
          
          if (shouldRemove) {
            editFabricCanvas.remove(editCurrentObject);
          } else {
            editFabricCanvas.setActiveObject(editCurrentObject);
            saveEditState();
            setEditTool('select');
          }
          
          editCurrentObject = null;
          editFabricCanvas.requestRenderAll();
        }
      });

      // Object modification listeners
      editFabricCanvas.on('object:modified', saveEditState);
      editFabricCanvas.on('object:removed', saveEditState);
      editFabricCanvas.on('selection:created', updateEditProps);
      editFabricCanvas.on('selection:updated', updateEditProps);
      editFabricCanvas.on('selection:cleared', updateEditProps);

      // Keyboard shortcuts
      document.addEventListener('keydown', e => {
        if (!editFabricCanvas || currentTool !== 'edit') return;
        
        let activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          return;
        }
        
        if (e.key === 'Escape') {
          setEditTool('select');
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          e.preventDefault();
          deleteActiveEditObject();
        } else if (e.ctrlKey && e.key === 'z') {
          e.preventDefault();
          editUndo();
        } else if (e.ctrlKey && e.key === 'y') {
          e.preventDefault();
          editRedo();
        }
      });
    }

    function setEditTool(t) {
      editTool = t;
      editFabricCanvas.isDrawingMode = (t === 'highlight' || t === 'signature');
      document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
      let btn = document.getElementById('edit_tool_' + t);
      if (btn) btn.classList.add('active');
      
      if (t !== 'select') {
        editFabricCanvas.discardActiveObject();
        editFabricCanvas.requestRenderAll();
      }
      
      if (t === 'highlight') {
        editFabricCanvas.freeDrawingBrush = new fabric.PencilBrush(editFabricCanvas);
        editFabricCanvas.freeDrawingBrush.width = 20;
        editFabricCanvas.freeDrawingBrush.color = "rgba(255,255,0,0.3)";
      }
      if (t === 'signature') {
        editFabricCanvas.freeDrawingBrush = new fabric.PencilBrush(editFabricCanvas);
        editFabricCanvas.freeDrawingBrush.width = 4;
        editFabricCanvas.freeDrawingBrush.color = "#111";
      }
    }

    async function handleEditFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const ab = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
        editPdfPages = [];
        editPdfImages = [];
        
        for (let i = 1; i <= pdf.numPages; i++) {
          let page = await pdf.getPage(i);
          editPdfPages.push(page);
          
          let viewport = page.getViewport({ scale: 1.0 });
          let c = document.createElement('canvas');
          c.width = viewport.width;
          c.height = viewport.height;
          let ctx = c.getContext('2d');
          await page.render({ canvasContext: ctx, viewport: viewport }).promise;
          editPdfImages.push(c.toDataURL("image/png"));
        }
        
        editPageNum = 0;
        editScale = 1;
        editPdfLoaded = true;
        
        // Hide drop zone and show canvas
        const dropZone = document.getElementById('edit-drop-zone');
        if (dropZone) dropZone.style.display = 'none';
        
        renderEditPage();
      } catch (error) {
        console.error('Error opening PDF:', error);
        alert('ไม่สามารถเปิดไฟล์ PDF ได้');
      }
    }

    async function openEditPdf(input) {
      await handleEditFile({ target: input });
    }

    function renderEditPage() {
      if (!editPdfLoaded || !editPdfImages[editPageNum]) return;
      
      let imgUrl = editPdfImages[editPageNum];
      let c = document.getElementById('edit-fabric-canvas');
      let img = new window.Image();
      
      img.onload = function() {
        editPdfW = img.width * editScale;
        editPdfH = img.height * editScale;
        c.width = editPdfW;
        c.height = editPdfH;
        editFabricCanvas.setWidth(editPdfW);
        editFabricCanvas.setHeight(editPdfH);
        
        fabric.Image.fromURL(imgUrl, function(bgImg) {
          editFabricCanvas.setBackgroundImage(bgImg, editFabricCanvas.renderAll.bind(editFabricCanvas), {
            scaleX: editPdfW / img.width,
            scaleY: editPdfH / img.height
          });
        });
        
        document.getElementById('edit-page-view').innerText = (editPageNum + 1) + "/" + editPdfPages.length;
        document.getElementById('edit-zoom-view').innerText = Math.round(editScale * 100) + "%";
      };
      
      img.src = imgUrl;
    }

    function prevEditPage() {
      if (editPageNum > 0) {
        editPageNum--;
        renderEditPage();
      }
    }

    function nextEditPage() {
      if (editPdfPages.length > 0 && editPageNum < editPdfPages.length - 1) {
        editPageNum++;
        renderEditPage();
      }
    }

    function editZoom(delta) {
      editScale = Math.max(0.25, Math.min(2.5, editScale + delta * 0.1));
      renderEditPage();
    }

    function saveEditState() {
      if (editHistory.length > maxEditHistory) editHistory.shift();
      editHistory.push(JSON.stringify(editFabricCanvas));
      editRedoStack = [];
    }

    function editUndo() {
      if (editHistory.length > 1) {
        editRedoStack.push(editHistory.pop());
        editFabricCanvas.loadFromJSON(editHistory[editHistory.length - 1], () => {
          editFabricCanvas.renderAll();
          updateEditProps();
        });
      }
    }

    function editRedo() {
      if (editRedoStack.length) {
        let s = editRedoStack.pop();
        editHistory.push(s);
        editFabricCanvas.loadFromJSON(s, () => {
          editFabricCanvas.renderAll();
          updateEditProps();
        });
      }
    }

    function updateEditProps() {
      let obj = editFabricCanvas.getActiveObject();
      let p = document.getElementById('edit-prop-panel');
      if (!obj) {
        p.innerHTML = '<span class="text-gray-400">เลือกวัตถุเพื่อดูรายละเอียด</span>';
        return;
      }
      
      let html = '';
      
      if (obj.type === 'i-text' || obj.type === 'textbox' || obj.type === 'text') {
        html += `<label>ข้อความ <input type="text" value="${obj.text || ''}" oninput="editFabricCanvas.getActiveObject().set('text',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label>Font <select onchange="editFabricCanvas.getActiveObject().set('fontFamily',this.value);editFabricCanvas.requestRenderAll();">
          ${PDF_FONTS.map(f => `<option value="${f}"${obj.fontFamily === f ? ' selected' : ''}>${f}</option>`).join('')}
        </select></label>
        <label>ขนาด <input type="number" value="${obj.fontSize || 32}" min="8" max="144" oninput="editFabricCanvas.getActiveObject().set('fontSize',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>
        <label>สี <input type="color" value="${obj.fill || '#000000'}" onchange="editFabricCanvas.getActiveObject().set('fill',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label><input type="checkbox" ${obj.fontWeight === 'bold' ? 'checked' : ''} onchange="editFabricCanvas.getActiveObject().set('fontWeight',this.checked?'bold':'normal');editFabricCanvas.requestRenderAll();"> Bold</label>
        <label><input type="checkbox" ${obj.fontStyle === 'italic' ? 'checked' : ''} onchange="editFabricCanvas.getActiveObject().set('fontStyle',this.checked?'italic':'normal');editFabricCanvas.requestRenderAll();"> Italic</label>
        <label><input type="checkbox" ${obj.underline ? 'checked' : ''} onchange="editFabricCanvas.getActiveObject().set('underline',this.checked);editFabricCanvas.requestRenderAll();"> Underline</label>
        <label>Align <select onchange="editFabricCanvas.getActiveObject().set('textAlign',this.value);editFabricCanvas.requestRenderAll();">
          <option value="left"${obj.textAlign === 'left' ? ' selected' : ''}>ซ้าย</option>
          <option value="center"${obj.textAlign === 'center' ? ' selected' : ''}>กลาง</option>
          <option value="right"${obj.textAlign === 'right' ? ' selected' : ''}>ขวา</option>
        </select></label>`;
      } else if (obj.type === 'path') {
        let strokeColor = obj.stroke || '#000000';
        if (typeof strokeColor === 'string' && strokeColor.includes('rgba')) {
          strokeColor = '#ffff00';
        }
        html += `<label>สีเส้น <input type="color" value="${strokeColor}" onchange="editFabricCanvas.getActiveObject().set('stroke',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label>ความหนา <input type="range" min="1" max="50" value="${obj.strokeWidth || 4}" oninput="editFabricCanvas.getActiveObject().set('strokeWidth',parseInt(this.value));editFabricCanvas.requestRenderAll();"> <span>${obj.strokeWidth || 4}px</span></label>
        <label>ความโปร่งใส <input type="range" min="0.1" max="1" step="0.1" value="${obj.opacity || 1}" oninput="editFabricCanvas.getActiveObject().set('opacity',parseFloat(this.value));editFabricCanvas.requestRenderAll();"> <span>${Math.round((obj.opacity || 1) * 100)}%</span></label>`;
      } else if (obj.type === 'rect' || obj.type === 'circle') {
        html += `<label>สีพื้น <input type="color" value="${obj.fill || '#ffffff'}" onchange="editFabricCanvas.getActiveObject().set('fill',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label>สีขอบ <input type="color" value="${obj.stroke || '#000000'}" onchange="editFabricCanvas.getActiveObject().set('stroke',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label>ความหนาขอบ <input type="number" min="0" max="20" value="${obj.strokeWidth || 2}" oninput="editFabricCanvas.getActiveObject().set('strokeWidth',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>`;
      } else if (obj.type === 'line') {
        html += `<label>สีเส้น <input type="color" value="${obj.stroke || '#000000'}" onchange="editFabricCanvas.getActiveObject().set('stroke',this.value);editFabricCanvas.requestRenderAll();"></label>
        <label>ความหนา <input type="number" min="1" max="20" value="${obj.strokeWidth || 3}" oninput="editFabricCanvas.getActiveObject().set('strokeWidth',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>`;
      }
      
      html += `<label>X <input type="number" value="${Math.round(obj.left || 0)}" oninput="editFabricCanvas.getActiveObject().set('left',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>
      <label>Y <input type="number" value="${Math.round(obj.top || 0)}" oninput="editFabricCanvas.getActiveObject().set('top',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>`;
      
      if (obj.type !== 'line' && obj.type !== 'path') {
        html += `<label>W <input type="number" value="${Math.round(obj.width || 0)}" oninput="editFabricCanvas.getActiveObject().set('width',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>
        <label>H <input type="number" value="${Math.round(obj.height || 0)}" oninput="editFabricCanvas.getActiveObject().set('height',parseInt(this.value));editFabricCanvas.requestRenderAll();"></label>`;
      }
      
      html += `<button class="bg-red-500 px-3 py-1 rounded text-white mt-3" onclick="deleteActiveEditObject()">ลบวัตถุ</button>`;
      p.innerHTML = html;
    }

    function deleteActiveEditObject() {
      let obj = editFabricCanvas.getActiveObject();
      if (obj) {
        editFabricCanvas.remove(obj);
        editFabricCanvas.discardActiveObject();
        editFabricCanvas.requestRenderAll();
        updateEditProps();
      }
    }

    async function saveEditedPdf() {
      if (!editPdfLoaded) {
        alert('ต้องเปิด PDF ก่อน');
        return;
      }
      
      try {
        const pdfDoc = await PDFLib.PDFDocument.create();
        let dataUrl = editFabricCanvas.toDataURL({ format: "png" });
        let imgEmbed = await pdfDoc.embedPng(dataUrl);
        let page = pdfDoc.addPage([editPdfW, editPdfH]);
        page.drawImage(imgEmbed, { x: 0, y: 0, width: editPdfW, height: editPdfH });
        const bytes = await pdfDoc.save();
        let blob = new Blob([bytes], { type: 'application/pdf' });
        let a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "edited.pdf";
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (error) {
        console.error('Error saving PDF:', error);
        alert('เกิดข้อผิดพลาดในการบันทึก PDF');
      }
    }

    // Sign PDF Preview Functions
    async function showSignPreview() {
      if (signedPdfBlob) {
        signPreviewDoc = signedPdfBlob;
        signPreviewCurrentPage = 0;
        signPreviewTotalPages = await generatePdfPreview(signedPdfBlob, 'sign-result-canvas', 'sign-preview-info', 0);
      }
    }

    function prevSignPreview() {
      if (signPreviewCurrentPage > 0) {
        signPreviewCurrentPage--;
        generatePdfPreview(signPreviewDoc, 'sign-result-canvas', 'sign-preview-info', signPreviewCurrentPage);
      }
    }

    function nextSignPreview() {
      if (signPreviewCurrentPage < signPreviewTotalPages - 1) {
        signPreviewCurrentPage++;
        generatePdfPreview(signPreviewDoc, 'sign-result-canvas', 'sign-preview-info', signPreviewCurrentPage);
      }
    }

    // Watermark Preview Functions
    async function showWatermarkPreview() {
      if (watermarkedPdfBlob) {
        watermarkPreviewDoc = watermarkedPdfBlob;
        watermarkPreviewCurrentPage = 0;
        watermarkPreviewTotalPages = await generatePdfPreview(watermarkedPdfBlob, 'watermark-result-canvas', 'watermark-preview-info', 0);
      }
    }

    function prevWatermarkPreview() {
      if (watermarkPreviewCurrentPage > 0) {
        watermarkPreviewCurrentPage--;
        generatePdfPreview(watermarkPreviewDoc, 'watermark-result-canvas', 'watermark-preview-info', watermarkPreviewCurrentPage);
      }
    }

    function nextWatermarkPreview() {
      if (watermarkPreviewCurrentPage < watermarkPreviewTotalPages - 1) {
        watermarkPreviewCurrentPage++;
        generatePdfPreview(watermarkPreviewDoc, 'watermark-result-canvas', 'watermark-preview-info', watermarkPreviewCurrentPage);
      }
    }

    // Rotate Preview Functions
    async function showRotatePreview() {
      if (rotatedPdfBlob) {
        rotatePreviewDoc = rotatedPdfBlob;
        rotatePreviewCurrentPage = 0;
        rotatePreviewTotalPages = await generatePdfPreview(rotatedPdfBlob, 'rotate-result-canvas', 'rotate-preview-info', 0);
      }
    }

    function prevRotatePreview() {
      if (rotatePreviewCurrentPage > 0) {
        rotatePreviewCurrentPage--;
        generatePdfPreview(rotatePreviewDoc, 'rotate-result-canvas', 'rotate-preview-info', rotatePreviewCurrentPage);
      }
    }

    function nextRotatePreview() {
      if (rotatePreviewCurrentPage < rotatePreviewTotalPages - 1) {
        rotatePreviewCurrentPage++;
        generatePdfPreview(rotatePreviewDoc, 'rotate-result-canvas', 'rotate-preview-info', rotatePreviewCurrentPage);
      }
    }

    // Protect Preview Functions
    async function showProtectPreview() {
      if (protectedPdfBlob) {
        protectPreviewDoc = protectedPdfBlob;
        protectPreviewCurrentPage = 0;
        protectPreviewTotalPages = await generatePdfPreview(protectedPdfBlob, 'protect-result-canvas', 'protect-preview-info', 0);
      }
    }

    function prevProtectPreview() {
      if (protectPreviewCurrentPage > 0) {
        protectPreviewCurrentPage--;
        generatePdfPreview(protectPreviewDoc, 'protect-result-canvas', 'protect-preview-info', protectPreviewCurrentPage);
      }
    }

    function nextProtectPreview() {
      if (protectPreviewCurrentPage < protectPreviewTotalPages - 1) {
        protectPreviewCurrentPage++;
        generatePdfPreview(protectPreviewDoc, 'protect-result-canvas', 'protect-preview-info', protectPreviewCurrentPage);
      }
    }

    // Navigation Functions
    function goBack() {
      if (currentTool) {
        showGrid();
      } else {
        window.history.back();
      }
    }

    function showGrid() {
      const gridElement = document.getElementById('pdf-tools-grid');
      if (gridElement) {
        gridElement.classList.remove('hidden');
      }
      
      document.querySelectorAll('[id$="-tool"]').forEach(tool => {
        tool.classList.add('hidden');
      });
      currentTool = null;
      window.history.pushState({}, '', '#pdftools');
    }

    function openTool(toolName) {
      console.log('Opening tool:', toolName);
      const gridElement = document.getElementById('pdf-tools-grid');
      if (gridElement) {
        gridElement.classList.add('hidden');
      }
      
      document.querySelectorAll('[id$="-tool"]').forEach(tool => {
        tool.classList.add('hidden');
      });
      
      const toolElement = document.getElementById(`${toolName}-tool`);
      if (toolElement) {
        toolElement.classList.remove('hidden');
        currentTool = toolName;
        window.history.pushState({}, '', `#pdftools-${toolName}`);
        console.log('Tool opened successfully:', toolName);
        
        // Initialize specific tools
        if (toolName === 'sign') {
          initializeSignTool();
        } else if (toolName === 'watermark') {
          initializeWatermarkTool();
        } else if (toolName === 'rotate') {
          initializeRotateTool();
        } else if (toolName === 'protect') {
          initializeProtectTool();
        }
      } else {
        alert(`เครื่องมือ ${toolName} กำลังพัฒนา จะเปิดให้ใช้งานเร็วๆ นี้`);
      }
    }

    // Sign PDF Functions
    function initializeSignTool() {
      setupSignListeners();
      setupSignatureCanvas();
      setupSignTypeListeners();
    }

    function setupSignListeners() {
      const fileInput = document.getElementById('sign-file');
      const dropZone = document.getElementById('sign-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleSignFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleSignFile({ target: fileInput });
          }
        });
      }
    }

    function setupSignatureCanvas() {
      const canvas = document.getElementById('signature-canvas');
      if (canvas) {
        signCanvas = canvas;
        const ctx = signCanvas.getContext('2d');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        function startDrawing(e) {
          isDrawing = true;
          [lastX, lastY] = getMousePos(e);
        }
        
        function draw(e) {
          if (!isDrawing) return;
          
          const [currentX, currentY] = getMousePos(e);
          
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(currentX, currentY);
          ctx.stroke();
          
          [lastX, lastY] = [currentX, currentY];
        }
        
        function stopDrawing() {
          isDrawing = false;
        }
        
        function getMousePos(e) {
          const rect = signCanvas.getBoundingClientRect();
          const scaleX = signCanvas.width / rect.width;
          const scaleY = signCanvas.height / rect.height;
          
          if (e.touches) {
            return [
              (e.touches[0].clientX - rect.left) * scaleX,
              (e.touches[0].clientY - rect.top) * scaleY
            ];
          } else {
            return [
              (e.clientX - rect.left) * scaleX,
              (e.clientY - rect.top) * scaleY
            ];
          }
        }
        
        // Mouse events
        signCanvas.addEventListener('mousedown', startDrawing);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('mouseup', stopDrawing);
        signCanvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events
        signCanvas.addEventListener('touchstart', startDrawing);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('touchend', stopDrawing);
      }
    }

    function setupSignTypeListeners() {
      const signTypeRadios = document.querySelectorAll('input[name="sign-type"]');
      signTypeRadios.forEach(radio => {
        radio.addEventListener('change', handleSignTypeChange);
      });
      
      const signSizeSlider = document.getElementById('sign-size');
      if (signSizeSlider) {
        signSizeSlider.addEventListener('input', (e) => {
          document.getElementById('sign-size-value').textContent = e.target.value;
        });
      }
      
      const signImageInput = document.getElementById('sign-image');
      if (signImageInput) {
        signImageInput.addEventListener('change', handleSignImageUpload);
      }
    }

    function handleSignTypeChange(e) {
      const signType = e.target.value;
      const textOptions = document.getElementById('text-sign-options');
      const uploadOptions = document.getElementById('upload-sign-options');
      const drawArea = document.getElementById('signature-draw-area');
      const positionOptions = document.getElementById('position-options');
      
      // Hide all options first
      if (textOptions) textOptions.classList.add('hidden');
      if (uploadOptions) uploadOptions.classList.add('hidden');
      if (drawArea) drawArea.classList.add('hidden');
      
      // Show relevant options
      switch(signType) {
        case 'draw':
          if (drawArea) drawArea.classList.remove('hidden');
          break;
        case 'text':
          if (textOptions) textOptions.classList.remove('hidden');
          break;
        case 'upload':
          if (uploadOptions) uploadOptions.classList.remove('hidden');
          break;
      }
      
      if (positionOptions) positionOptions.classList.remove('hidden');
    }

    function handleSignImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          signatureImage = event.target.result;
          const preview = document.getElementById('sign-image-preview');
          const previewImg = document.getElementById('preview-img');
          if (preview && previewImg) {
            previewImg.src = signatureImage;
            preview.classList.remove('hidden');
          }
        };
        reader.readAsDataURL(file);
      }
    }

    async function handleSignFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        signPdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        signTotalPages = signPdfDoc.getPageCount();
        signCurrentPage = 0;
        
        // Update UI
        const preview = document.getElementById('sign-preview');
        const applyBtn = document.getElementById('apply-sign-btn');
        
        if (preview) preview.classList.remove('hidden');
        if (applyBtn) applyBtn.disabled = false;
        
        await renderSignPage();
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        alert('ไม่สามารถโหลดไฟล์ PDF ได้');
      }
    }

    async function renderSignPage() {
      if (!signPdfDoc) return;
      
      try {
        const page = signPdfDoc.getPage(signCurrentPage);
        const { width, height } = page.getSize();
        
        // Create a temporary PDF to render the page
        const tempPdf = await PDFLib.PDFDocument.create();
        const [copiedPage] = await tempPdf.copyPages(signPdfDoc, [signCurrentPage]);
        tempPdf.addPage(copiedPage);
        
        const pdfBytes = await tempPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        
        if (typeof pdfjsLib !== 'undefined') {
          const pdf = await pdfjsLib.getDocument({ url: url }).promise;
          const pdfPage = await pdf.getPage(1);
          
          const canvas = document.getElementById('sign-pdf-canvas');
          const context = canvas.getContext('2d');
          const viewport = pdfPage.getViewport({ scale: 1 });
          
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          
          await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;
        }
        
        // Update page info
        const pageInfo = document.getElementById('sign-page-info');
        if (pageInfo) {
          pageInfo.textContent = `${signCurrentPage + 1}/${signTotalPages}`;
        }
        
        URL.revokeObjectURL(url);
        
      } catch (error) {
        console.error('Error rendering page:', error);
      }
    }

    function prevSignPage() {
      if (signCurrentPage > 0) {
        signCurrentPage--;
        renderSignPage();
      }
    }

    function nextSignPage() {
      if (signCurrentPage < signTotalPages - 1) {
        signCurrentPage++;
        renderSignPage();
      }
    }

    function clearSignature() {
      if (signCanvas) {
        const ctx = signCanvas.getContext('2d');
        ctx.clearRect(0, 0, signCanvas.width, signCanvas.height);
      }
    }

    function saveSignature() {
      if (signCanvas) {
        signatureImage = signCanvas.toDataURL();
        alert('ลายเซ็นถูกบันทึกแล้ว');
      }
    }

    function setSignPosition(position) {
      signPosition = position;
      // Update button styles
      document.querySelectorAll('[onclick^="setSignPosition"]').forEach(btn => {
        btn.classList.remove('bg-indigo-50', 'border-indigo-300');
      });
      event.target.classList.add('bg-indigo-50', 'border-indigo-300');
    }

    async function executeSign() {
      if (!signPdfDoc) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      const signType = document.querySelector('input[name="sign-type"]:checked').value;
      const progress = document.getElementById('sign-progress');
      const progressBar = document.getElementById('sign-progress-bar');
      const progressText = document.getElementById('sign-progress-text');
      const result = document.getElementById('sign-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        const newPdf = await PDFLib.PDFDocument.create();
        const pages = await newPdf.copyPages(signPdfDoc, signPdfDoc.getPageIndices());
        
        pages.forEach(page => newPdf.addPage(page));
        
        // Determine which pages to sign
        const pageSelect = document.getElementById('sign-page-select');
        const pageOption = pageSelect ? pageSelect.value : 'last';
        let pagesToSign = [];
        
        switch(pageOption) {
          case 'first':
            pagesToSign = [0];
            break;
          case 'last':
            pagesToSign = [pages.length - 1];
            break;
          case 'all':
            pagesToSign = Array.from({length: pages.length}, (_, i) => i);
            break;
        }
        
        for (let pageIndex of pagesToSign) {
          const page = newPdf.getPage(pageIndex);
          const { width, height } = page.getSize();
          
          if (progressText) progressText.textContent = `กำลังเซ็นหน้า ${pageIndex + 1}...`;
          if (progressBar) progressBar.style.width = `${((pageIndex + 1) / pagesToSign.length) * 90}%`;
          
          let signatureData = null;
          
          if (signType === 'draw' && signatureImage) {
            signatureData = await newPdf.embedPng(signatureImage);
          } else if (signType === 'upload' && signatureImage) {
            if (signatureImage.includes('data:image/png')) {
              signatureData = await newPdf.embedPng(signatureImage);
            } else {
              signatureData = await newPdf.embedJpg(signatureImage);
            }
          } else if (signType === 'text') {
            const signText = document.getElementById('sign-text').value;
            const signFont = document.getElementById('sign-font').value;
            const signSize = parseInt(document.getElementById('sign-size').value);
            
            if (signText) {
              let font;
              try {
                font = await newPdf.embedFont(PDFLib.StandardFonts.Helvetica);
              } catch {
                font = await newPdf.embedFont(PDFLib.StandardFonts.Helvetica);
              }
              
              const textWidth = font.widthOfTextAtSize(signText, signSize);
              const textHeight = signSize;
              
              const { x, y } = getPositionCoordinates(signPosition, width, height, textWidth, textHeight);
              
              page.drawText(signText, {
                x: x,
                y: y,
                size: signSize,
                font: font,
                color: PDFLib.rgb(0, 0, 0)
              });
              
              await new Promise(resolve => setTimeout(resolve, 100));
              continue;
            }
          }
          
          if (signatureData) {
            const signatureSize = 100;
            const { x, y } = getPositionCoordinates(signPosition, width, height, signatureSize, signatureSize);
            
            page.drawImage(signatureData, {
              x: x,
              y: y,
              width: signatureSize,
              height: signatureSize * 0.5
            });
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์...';
        if (progressBar) progressBar.style.width = '100%';
        
        const pdfBytes = await newPdf.save();
        signedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        setTimeout(async () => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          // Show preview
          await showSignPreview();
        }, 1000);
        
      } catch (error) {
        console.error('Error signing PDF:', error);
        alert('เกิดข้อผิดพลาดในการเซ็นลายเซ็น: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function getPositionCoordinates(position, pageWidth, pageHeight, objectWidth, objectHeight) {
      const margin = 20;
      
      switch(position) {
        case 'top-left':
          return { x: margin, y: pageHeight - objectHeight - margin };
        case 'top-center':
          return { x: (pageWidth - objectWidth) / 2, y: pageHeight - objectHeight - margin };
        case 'top-right':
          return { x: pageWidth - objectWidth - margin, y: pageHeight - objectHeight - margin };
        case 'center-left':
          return { x: margin, y: (pageHeight - objectHeight) / 2 };
        case 'center':
          return { x: (pageWidth - objectWidth) / 2, y: (pageHeight - objectHeight) / 2 };
        case 'center-right':
          return { x: pageWidth - objectWidth - margin, y: (pageHeight - objectHeight) / 2 };
        case 'bottom-left':
          return { x: margin, y: margin };
        case 'bottom-center':
          return { x: (pageWidth - objectWidth) / 2, y: margin };
        case 'bottom-right':
        default:
          return { x: pageWidth - objectWidth - margin, y: margin };
      }
    }

    function downloadSignedFile() {
      if (signedPdfBlob) {
        const url = URL.createObjectURL(signedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `signed-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Watermark PDF Functions
    function initializeWatermarkTool() {
      setupWatermarkListeners();
      setupWatermarkControls();
    }

    function setupWatermarkListeners() {
      const fileInput = document.getElementById('watermark-file');
      const dropZone = document.getElementById('watermark-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleWatermarkFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleWatermarkFile({ target: fileInput });
          }
        });
      }
    }

    function setupWatermarkControls() {
      // Watermark type listeners
      const watermarkTypeRadios = document.querySelectorAll('input[name="watermark-type"]');
      watermarkTypeRadios.forEach(radio => {
        radio.addEventListener('change', handleWatermarkTypeChange);
      });
      
      // Slider listeners
      const watermarkSize = document.getElementById('watermark-size');
      if (watermarkSize) {
        watermarkSize.addEventListener('input', (e) => {
          document.getElementById('watermark-size-value').textContent = e.target.value;
        });
      }
      
      const watermarkOpacity = document.getElementById('watermark-opacity');
      if (watermarkOpacity) {
        watermarkOpacity.addEventListener('input', (e) => {
          document.getElementById('watermark-opacity-value').textContent = e.target.value;
        });
      }
      
      const watermarkScale = document.getElementById('watermark-scale');
      if (watermarkScale) {
        watermarkScale.addEventListener('input', (e) => {
          document.getElementById('watermark-scale-value').textContent = e.target.value;
        });
      }
      
      const watermarkImgOpacity = document.getElementById('watermark-img-opacity');
      if (watermarkImgOpacity) {
        watermarkImgOpacity.addEventListener('input', (e) => {
          document.getElementById('watermark-img-opacity-value').textContent = e.target.value;
        });
      }
      
      const watermarkRotation = document.getElementById('watermark-rotation');
      if (watermarkRotation) {
        watermarkRotation.addEventListener('input', (e) => {
          document.getElementById('watermark-rotation-value').textContent = e.target.value;
        });
      }
      
      // Image upload listener
      const watermarkImageInput = document.getElementById('watermark-image');
      if (watermarkImageInput) {
        watermarkImageInput.addEventListener('change', handleWatermarkImageUpload);
      }
    }

    function handleWatermarkTypeChange(e) {
      const watermarkType = e.target.value;
      const textOptions = document.getElementById('watermark-text-options');
      const imageOptions = document.getElementById('watermark-image-options');
      
      if (watermarkType === 'text') {
        if (textOptions) textOptions.classList.remove('hidden');
        if (imageOptions) imageOptions.classList.add('hidden');
      } else {
        if (textOptions) textOptions.classList.add('hidden');
        if (imageOptions) imageOptions.classList.remove('hidden');
      }
    }

    function handleWatermarkImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          watermarkImageData = event.target.result;
          const preview = document.getElementById('watermark-image-preview');
          const previewImg = document.getElementById('watermark-preview-img');
          if (preview && previewImg) {
            previewImg.src = watermarkImageData;
            preview.classList.remove('hidden');
          }
        };
        reader.readAsDataURL(file);
      }
    }

    async function handleWatermarkFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        watermarkPdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        watermarkTotalPages = watermarkPdfDoc.getPageCount();
        watermarkCurrentPage = 0;
        
        // Update UI
        const preview = document.getElementById('watermark-preview');
        const applyBtn = document.getElementById('apply-watermark-btn');
        
        if (preview) preview.classList.remove('hidden');
        if (applyBtn) applyBtn.disabled = false;
        
        await renderWatermarkPage();
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        alert('ไม่สามารถโหลดไฟล์ PDF ได้');
      }
    }

    async function renderWatermarkPage() {
      if (!watermarkPdfDoc) return;
      
      try {
        const page = watermarkPdfDoc.getPage(watermarkCurrentPage);
        const { width, height } = page.getSize();
        
        // Create a temporary PDF to render the page
        const tempPdf = await PDFLib.PDFDocument.create();
        const [copiedPage] = await tempPdf.copyPages(watermarkPdfDoc, [watermarkCurrentPage]);
        tempPdf.addPage(copiedPage);
        
        const pdfBytes = await tempPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        
        if (typeof pdfjsLib !== 'undefined') {
          const pdf = await pdfjsLib.getDocument({ url: url }).promise;
          const pdfPage = await pdf.getPage(1);
          
          const canvas = document.getElementById('watermark-pdf-canvas');
          const context = canvas.getContext('2d');
          const viewport = pdfPage.getViewport({ scale: 1 });
          
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          
          await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;
        }
        
        // Update page info
        const pageInfo = document.getElementById('watermark-page-info');
        if (pageInfo) {
          pageInfo.textContent = `${watermarkCurrentPage + 1}/${watermarkTotalPages}`;
        }
        
        URL.revokeObjectURL(url);
        
      } catch (error) {
        console.error('Error rendering page:', error);
      }
    }

    function prevWatermarkPage() {
      if (watermarkCurrentPage > 0) {
        watermarkCurrentPage--;
        renderWatermarkPage();
      }
    }

    function nextWatermarkPage() {
      if (watermarkCurrentPage < watermarkTotalPages - 1) {
        watermarkCurrentPage++;
        renderWatermarkPage();
      }
    }

    function setWatermarkPosition(position) {
      watermarkPosition = position;
      // Update button styles
      document.querySelectorAll('[onclick^="setWatermarkPosition"]').forEach(btn => {
        btn.classList.remove('bg-cyan-50', 'border-cyan-300');
      });
      event.target.classList.add('bg-cyan-50', 'border-cyan-300');
    }

    async function executeWatermark() {
      if (!watermarkPdfDoc) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      const watermarkType = document.querySelector('input[name="watermark-type"]:checked').value;
      const progress = document.getElementById('watermark-progress');
      const progressBar = document.getElementById('watermark-progress-bar');
      const progressText = document.getElementById('watermark-progress-text');
      const result = document.getElementById('watermark-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        const newPdf = await PDFLib.PDFDocument.create();
        const pages = await newPdf.copyPages(watermarkPdfDoc, watermarkPdfDoc.getPageIndices());
        
        pages.forEach(page => newPdf.addPage(page));
        
        const totalPages = pages.length;
        
        for (let i = 0; i < totalPages; i++) {
          const page = newPdf.getPage(i);
          const { width, height } = page.getSize();
          
          if (progressText) progressText.textContent = `กำลังเพิ่มลายน้ำในหน้า ${i + 1}...`;
          if (progressBar) progressBar.style.width = `${((i + 1) / totalPages) * 90}%`;
          
          if (watermarkType === 'text') {
            const text = document.getElementById('watermark-text').value || 'CONFIDENTIAL';
            const fontSize = parseInt(document.getElementById('watermark-size').value) || 48;
            const color = document.getElementById('watermark-color').value || '#808080';
            const opacity = parseInt(document.getElementById('watermark-opacity').value) / 100 || 0.3;
            const rotation = parseInt(document.getElementById('watermark-rotation').value) || 0;
            
            const font = await newPdf.embedFont(PDFLib.StandardFonts.Helvetica);
            const textWidth = font.widthOfTextAtSize(text, fontSize);
            const textHeight = fontSize;
            
            const { x, y } = getPositionCoordinates(watermarkPosition, width, height, textWidth, textHeight);
            
            // Convert hex color to RGB
            const hexColor = color.replace('#', '');
            const r = parseInt(hexColor.substr(0, 2), 16) / 255;
            const g = parseInt(hexColor.substr(2, 2), 16) / 255;
            const b = parseInt(hexColor.substr(4, 2), 16) / 255;
            
            page.drawText(text, {
              x: x,
              y: y,
              size: fontSize,
              font: font,
              color: PDFLib.rgb(r, g, b),
              opacity: opacity,
              rotate: PDFLib.degrees(rotation)
            });
            
          } else if (watermarkType === 'image' && watermarkImageData) {
            const scale = parseInt(document.getElementById('watermark-scale').value) / 100 || 0.5;
            const opacity = parseInt(document.getElementById('watermark-img-opacity').value) / 100 || 0.5;
            const rotation = parseInt(document.getElementById('watermark-rotation').value) || 0;
            
            let imageEmbed;
            if (watermarkImageData.includes('data:image/png')) {
              imageEmbed = await newPdf.embedPng(watermarkImageData);
            } else {
              imageEmbed = await newPdf.embedJpg(watermarkImageData);
            }
            
            const imageWidth = 200 * scale;
            const imageHeight = 200 * scale;
            
            const { x, y } = getPositionCoordinates(watermarkPosition, width, height, imageWidth, imageHeight);
            
            page.drawImage(imageEmbed, {
              x: x,
              y: y,
              width: imageWidth,
              height: imageHeight,
              opacity: opacity,
              rotate: PDFLib.degrees(rotation)
            });
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์...';
        if (progressBar) progressBar.style.width = '100%';
        
        const pdfBytes = await newPdf.save();
        watermarkedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        setTimeout(async () => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          // Show preview
          await showWatermarkPreview();
        }, 1000);
        
      } catch (error) {
        console.error('Error adding watermark:', error);
        alert('เกิดข้อผิดพลาดในการเพิ่มลายน้ำ: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function downloadWatermarkedFile() {
      if (watermarkedPdfBlob) {
        const url = URL.createObjectURL(watermarkedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `watermarked-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Rotate PDF Functions
    function initializeRotateTool() {
      setupRotateListeners();
    }

    function setupRotateListeners() {
      const fileInput = document.getElementById('rotate-file');
      const dropZone = document.getElementById('rotate-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleRotateFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleRotateFile({ target: fileInput });
          }
        });
      }
      
      // Setup rotate page selection listeners
      const rotatePageRadios = document.querySelectorAll('input[name="rotate-pages"]');
      rotatePageRadios.forEach(radio => {
        radio.addEventListener('change', handleRotatePageModeChange);
      });
    }

    function handleRotatePageModeChange(e) {
      const mode = e.target.value;
      const rangeInput = document.getElementById('rotate-range-input');
      const selectedInfo = document.getElementById('rotate-selected-info');
      
      if (mode === 'range') {
        if (rangeInput) rangeInput.classList.remove('hidden');
      } else {
        if (rangeInput) rangeInput.classList.add('hidden');
      }
      
      if (mode === 'selected') {
        if (selectedInfo) selectedInfo.classList.remove('hidden');
        updateRotateSelectedInfo();
      } else {
        if (selectedInfo) selectedInfo.classList.add('hidden');
      }
    }

    async function handleRotateFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        rotatePdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        const totalPages = rotatePdfDoc.getPageCount();
        
        // Update file details
        const fileDetails = document.getElementById('rotate-file-details');
        if (fileDetails) {
          fileDetails.innerHTML = `
            <strong>${file.name}</strong> • ${(file.size / 1024 / 1024).toFixed(2)} MB • ${totalPages} หน้า
          `;
        }
        
        // Update range inputs
        const fromPage = document.getElementById('rotate-from-page');
        const toPage = document.getElementById('rotate-to-page');
        if (fromPage) fromPage.max = totalPages;
        if (toPage) {
          toPage.max = totalPages;
          toPage.value = totalPages;
        }
        
        // Show pages container and enable apply button
        const pagesContainer = document.getElementById('rotate-pages-container');
        const applyBtn = document.getElementById('apply-rotate-btn');
        if (pagesContainer) pagesContainer.classList.remove('hidden');
        if (applyBtn) applyBtn.disabled = false;
        
        // Generate page thumbnails
        await generateRotatePageThumbnails(file, totalPages);
        
        // Select all pages by default
        selectAllRotatePages();
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        alert('ไม่สามารถโหลดไฟล์ PDF ได้');
      }
    }

    async function generateRotatePageThumbnails(file, totalPages) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        if (typeof pdfjsLib === 'undefined') {
          console.error('PDF.js not loaded');
          return;
        }
        
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const pagesGrid = document.getElementById('rotate-pages-grid');
        
        if (pagesGrid) {
          pagesGrid.innerHTML = '';
        }
        rotateSelectedPages.clear();
        
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 0.5 });
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          
          await page.render({
            canvasContext: context,
            viewport: viewport
          }).promise;
          
          // Create page item
          const pageItem = document.createElement('div');
          pageItem.className = 'pdf-page-item';
          pageItem.dataset.pageNumber = pageNum;
          pageItem.onclick = () => toggleRotatePageSelection(pageNum);
          
          pageItem.innerHTML = `
            <canvas class="pdf-page-canvas"></canvas>
            <div class="page-number-badge">${pageNum}</div>
            <div class="selection-indicator"></div>
          `;
          
          // Copy canvas
          const displayCanvas = pageItem.querySelector('.pdf-page-canvas');
          displayCanvas.width = canvas.width;
          displayCanvas.height = canvas.height;
          const displayContext = displayCanvas.getContext('2d');
          displayContext.drawImage(canvas, 0, 0);
          
          if (pagesGrid) {
            pagesGrid.appendChild(pageItem);
          }
        }
        
      } catch (error) {
        console.error('Error generating thumbnails:', error);
      }
    }

    function toggleRotatePageSelection(pageNumber) {
      const pageItem = document.querySelector(`[data-page-number="${pageNumber}"]`);
      
      if (rotateSelectedPages.has(pageNumber)) {
        rotateSelectedPages.delete(pageNumber);
        if (pageItem) pageItem.classList.remove('selected');
      } else {
        rotateSelectedPages.add(pageNumber);
        if (pageItem) pageItem.classList.add('selected');
      }
      
      updateRotateSelectedInfo();
    }

    function selectAllRotatePages() {
      const totalPages = rotatePdfDoc ? rotatePdfDoc.getPageCount() : 0;
      rotateSelectedPages.clear();
      for (let i = 1; i <= totalPages; i++) {
        rotateSelectedPages.add(i);
      }
      
      document.querySelectorAll('.pdf-page-item').forEach(item => {
        item.classList.add('selected');
      });
      
      updateRotateSelectedInfo();
    }

    function deselectAllRotatePages() {
      rotateSelectedPages.clear();
      
      document.querySelectorAll('.pdf-page-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      updateRotateSelectedInfo();
    }

    function updateRotateSelectedInfo() {
      const selectedCount = rotateSelectedPages.size;
      const selectedCountEl = document.getElementById('rotate-selected-count');
      
      if (selectedCountEl) {
        if (selectedCount === 0) {
          selectedCountEl.textContent = 'ไม่มีหน้าที่เลือก';
        } else {
          selectedCountEl.textContent = `เลือก ${selectedCount} หน้าที่จะหมุน`;
        }
      }
    }

    function setRotationDegree(degrees) {
      rotateAngle = degrees;
      
      // Update button styles
      document.querySelectorAll('.rotation-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      
      const selectedBtn = document.getElementById(`rotate-${degrees}`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }
    }

    async function executeRotate() {
      if (!rotatePdfDoc) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      const pageMode = document.querySelector('input[name="rotate-pages"]:checked').value;
      const progress = document.getElementById('rotate-progress');
      const progressBar = document.getElementById('rotate-progress-bar');
      const progressText = document.getElementById('rotate-progress-text');
      const result = document.getElementById('rotate-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        const newPdf = await PDFLib.PDFDocument.create();
        const originalPages = rotatePdfDoc.getPageIndices();
        const pages = await newPdf.copyPages(rotatePdfDoc, originalPages);
        
        pages.forEach(page => newPdf.addPage(page));
        
        // Determine which pages to rotate
        let pagesToRotate = [];
        
        switch(pageMode) {
          case 'all':
            pagesToRotate = Array.from({length: pages.length}, (_, i) => i);
            break;
          case 'selected':
            pagesToRotate = Array.from(rotateSelectedPages).map(p => p - 1); // Convert to 0-based
            break;
          case 'range':
            const fromPage = parseInt(document.getElementById('rotate-from-page').value) - 1;
            const toPage = parseInt(document.getElementById('rotate-to-page').value) - 1;
            pagesToRotate = Array.from({length: toPage - fromPage + 1}, (_, i) => fromPage + i);
            break;
        }
        
        for (let i = 0; i < pagesToRotate.length; i++) {
          const pageIndex = pagesToRotate[i];
          if (pageIndex >= 0 && pageIndex < pages.length) {
            const page = newPdf.getPage(pageIndex);
            page.setRotation(PDFLib.degrees(rotateAngle));
            
            if (progressText) progressText.textContent = `กำลังหมุนหน้า ${pageIndex + 1}...`;
            if (progressBar) progressBar.style.width = `${((i + 1) / pagesToRotate.length) * 90}%`;
            
            await new Promise(resolve => setTimeout(resolve, 50));
          }
        }
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์...';
        if (progressBar) progressBar.style.width = '100%';
        
        const pdfBytes = await newPdf.save();
        rotatedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        setTimeout(async () => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          // Show preview
          await showRotatePreview();
        }, 1000);
        
      } catch (error) {
        console.error('Error rotating PDF:', error);
        alert('เกิดข้อผิดพลาดในการหมุน PDF: ' + error.message);
        if (progress) progress.classList.add('hidden');
      }
    }

    function downloadRotatedFile() {
      if (rotatedPdfBlob) {
        const url = URL.createObjectURL(rotatedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `rotated-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Protect PDF Functions
    function initializeProtectTool() {
      setupProtectListeners();
    }

    function setupProtectListeners() {
      const fileInput = document.getElementById('protect-file');
      const dropZone = document.getElementById('protect-drop-zone');
      
      if (fileInput) {
        fileInput.addEventListener('change', handleProtectFile);
      }
      
      if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
          if (files.length === 1 && fileInput) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            fileInput.files = dt.files;
            handleProtectFile({ target: fileInput });
          }
        });
      }
      
      // Show passwords checkbox
      const showPasswordsCheckbox = document.getElementById('show-passwords');
      if (showPasswordsCheckbox) {
        showPasswordsCheckbox.addEventListener('change', (e) => {
          const userPassword = document.getElementById('user-password');
          const ownerPassword = document.getElementById('owner-password');
          
          if (userPassword) {
            userPassword.type = e.target.checked ? 'text' : 'password';
          }
          if (ownerPassword) {
            ownerPassword.type = e.target.checked ? 'text' : 'password';
          }
        });
      }
    }

    async function handleProtectFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        protectPdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        
        // Update file info
        const fileInfo = document.getElementById('protect-file-info');
        const originalInfo = document.getElementById('protect-original-info');
        const options = document.getElementById('protect-options');
        const protectBtn = document.getElementById('protect-btn');
        
        if (originalInfo) {
          originalInfo.innerHTML = `
            <div class="grid grid-cols-2 gap-4">
              <div>ชื่อไฟล์: <strong>${file.name}</strong></div>
              <div>ขนาดไฟล์: <strong>${(file.size / 1024 / 1024).toFixed(2)} MB</strong></div>
              <div>จำนวนหน้า: <strong>${protectPdfDoc.getPageCount()}</strong></div>
              <div>สถานะ: <strong class="text-red-600">ไม่มีการป้องกัน</strong></div>
            </div>
          `;
        }
        
        if (fileInfo) fileInfo.classList.remove('hidden');
        if (options) options.classList.remove('hidden');
        if (protectBtn) protectBtn.disabled = false;
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        alert('ไม่สามารถโหลดไฟล์ PDF ได้');
      }
    }

    // ⚠️ Advanced PDF Protection Function (สำหรับการป้องกันจริง)
    async function createPasswordProtectedPdf(originalPdfDoc, userPassword, ownerPassword, permissions) {
      try {
        // สำหรับการใช้งานจริง จำเป็นต้องใช้ไลบรารีที่รองรับการเข้ารหัส
        // เช่น HummusJS, PDFtk, หรือ server-side solution
        
        // ในที่นี้เราจะจำลองโดยการเพิ่ม metadata และแสดงการป้องกัน
        const newPdf = await PDFLib.PDFDocument.create();
        const pages = await newPdf.copyPages(originalPdfDoc, originalPdfDoc.getPageIndices());
        pages.forEach(page => newPdf.addPage(page));
        
        // เพิ่ม metadata ที่บ่งบอกว่ามีการป้องกัน
        newPdf.setTitle('Protected PDF Document');
        newPdf.setSubject('This document is password protected');
        newPdf.setCreator('Advanced PDF Tools - Protected');
        newPdf.setProducer('PDF Tools with Security');
        newPdf.setCreationDate(new Date());
        newPdf.setModificationDate(new Date());
        
        // สำหรับการใช้งานจริง ควรใช้ไลบรารีที่รองรับการเข้ารหัส
        // เช่น:
        // - HummusJS (https://github.com/galkahana/HummusPDF)
        // - PDFtk Server
        // - jsPDF with encryption plugins
        // - Server-side PDF processing
        
        return await newPdf.save();
      } catch (error) {
        throw new Error('การป้องกัน PDF ต้องการไลบรารีเฉพาะทาง: ' + error.message);
      }
    }

    async function executeProtect() {
      if (!protectPdfDoc) {
        alert('กรุณาเลือกไฟล์ PDF');
        return;
      }
      
      const userPassword = document.getElementById('user-password').value;
      const ownerPassword = document.getElementById('owner-password').value;
      
      if (!userPassword && !ownerPassword) {
        alert('กรุณาใส่รหัสผ่านอย่างน้อย 1 รหัส');
        return;
      }
      
      const progress = document.getElementById('protect-progress');
      const progressBar = document.getElementById('protect-progress-bar');
      const progressText = document.getElementById('protect-progress-text');
      const result = document.getElementById('protect-result');
      
      try {
        if (progress) progress.classList.remove('hidden');
        if (result) result.classList.add('hidden');
        
        if (progressText) progressText.textContent = 'กำลังเตรียมการป้องกัน...';
        if (progressBar) progressBar.style.width = '30%';
        
        if (progressText) progressText.textContent = 'กำลังตั้งค่าสิทธิ์...';
        if (progressBar) progressBar.style.width = '60%';
        
        // Get permissions
        const permissions = {
          printing: document.getElementById('allow-printing').checked,
          modifying: document.getElementById('allow-modify').checked,
          copying: document.getElementById('allow-copy').checked,
          annotating: document.getElementById('allow-annotations').checked,
          fillingForms: document.getElementById('allow-forms').checked,
          contentAccessibility: document.getElementById('allow-accessibility').checked,
          documentAssembly: document.getElementById('allow-assembly').checked,
          degradedPrinting: document.getElementById('allow-degraded-printing').checked
        };
        
        if (progressText) progressText.textContent = 'กำลังสร้างไฟล์ที่ป้องกัน...';
        if (progressBar) progressBar.style.width = '90%';
        
        // สร้าง PDF ที่มี metadata แสดงการป้องกัน
        const pdfBytes = await createPasswordProtectedPdf(protectPdfDoc, userPassword, ownerPassword, permissions);
        protectedPdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = 'เสร็จสิ้น!';
        
        setTimeout(async () => {
          if (progress) progress.classList.add('hidden');
          if (result) result.classList.remove('hidden');
          
          const protectStats = document.getElementById('protect-stats');
          if (protectStats) {
            protectStats.innerHTML = `
              <div class="space-y-2">
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                  <div class="flex items-center gap-2 text-yellow-800">
                    <span>⚠️</span>
                    <strong>ข้อมูลสำคัญ:</strong>
                  </div>
                  <div class="text-yellow-700 text-sm mt-2">
                    การป้องกันรหัสผ่านที่แท้จริงต้องใช้ไลบรารีเฉพาะทาง<br>
                    ไฟล์นี้มี metadata บ่งบอกการป้องกัน แต่ยังเปิดได้ปกติ<br>
                    สำหรับการใช้งานจริง แนะนำให้ใช้ PDFtk หรือ HummusJS
                  </div>
                </div>
                ${userPassword ? '<div>🔐 ตั้งค่ารหัสผ่านการเปิดไฟล์</div>' : ''}
                ${ownerPassword ? '<div>🛡️ ตั้งค่ารหัสผ่านการแก้ไข</div>' : ''}
                <div>📋 ตั้งค่าสิทธิ์การใช้งาน</div>
                <div class="text-sm text-gray-600 mt-2">
                  ไฟล์ได้รับการประมวลผลและเพิ่ม metadata แล้ว
                </div>
              </div>
            `;
          }
          
          // Show preview
          await showProtectPreview();
        }, 500);
        
      } catch (error) {
        console.error('Error protecting PDF:', error);
        
        // แสดงข้อผิดพลาดและข้อแนะนำ
        if (progress) progress.classList.add('hidden');
        
        alert(`เกิดข้อผิดพลาดในการป้องกัน PDF: ${error.message}\n\nสำหรับการป้องกันรหัสผ่านที่แท้จริง กรุณาใช้:\n- PDFtk Server\n- HummusJS\n- Adobe Acrobat\n- หรือบริการออนไลน์ที่รองรับการเข้ารหัส`);
      }
    }

    function downloadProtectedFile() {
      if (protectedPdfBlob) {
        const url = URL.createObjectURL(protectedPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `protected-${new Date().toISOString().split('T')[0]}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      console.log('🚀 Initializing PDF Tools...');
      
      // Setup event listeners for all tools
      setupMergeListeners();
      setupSplitListeners();
      setupCompressListeners();
      
      // Handle browser back/forward
      window.addEventListener('popstate', (e) => {
        const hash = window.location.hash;
        if (hash === '#pdftools' || hash === '') {
          showGrid();
        } else if (hash.startsWith('#pdftools-')) {
          const tool = hash.replace('#pdftools-', '');
          openTool(tool);
        }
      });
      
      // Initialize based on current hash
      const hash = window.location.hash;
      if (hash.startsWith('#pdftools-')) {
        const tool = hash.replace('#pdftools-', '');
        openTool(tool);
      }
      
      console.log('✅ Advanced PDF Tools initialized successfully');
    });

    // Make functions globally available for onclick handlers
    window.goBack = goBack;
    window.showGrid = showGrid;
    window.openTool = openTool;
    
    // Edit PDF functions
    window.setEditTool = setEditTool;
    window.openEditPdf = openEditPdf;
    window.prevEditPage = prevEditPage;
    window.nextEditPage = nextEditPage;
    window.editZoom = editZoom;
    window.editUndo = editUndo;
    window.editRedo = editRedo;
    window.saveEditedPdf = saveEditedPdf;
    window.deleteActiveEditObject = deleteActiveEditObject;
    
    // Split PDF functions
    window.switchSplitTab = switchSplitTab;
    window.selectRangeMode = selectRangeMode;
    window.addRange = addRange;
    window.removeRange = removeRange;
    window.executeSplit = executeSplit;
    window.downloadSplitFile = downloadSplitFile;
    window.downloadAllSplitFiles = downloadAllSplitFiles;
    window.togglePageSelection = togglePageSelection;
    window.selectAllPages = selectAllPages;
    window.deselectAllPages = deselectAllPages;
    
    // Merge PDF functions
    window.sortFiles = sortFiles;
    window.reverseOrder = reverseOrder;
    window.clearAllFiles = clearAllFiles;
    window.executeMerge = executeMerge;
    window.downloadMergedFile = downloadMergedFile;
    window.removeFile = removeFile;
    
    // Compress PDF functions
    window.selectCompressionLevel = selectCompressionLevel;
    window.executeCompress = executeCompress;
    window.downloadCompressedFile = downloadCompressedFile;
    
    // Sign PDF functions
    window.clearSignature = clearSignature;
    window.saveSignature = saveSignature;
    window.setSignPosition = setSignPosition;
    window.executeSign = executeSign;
    window.downloadSignedFile = downloadSignedFile;
    window.prevSignPage = prevSignPage;
    window.nextSignPage = nextSignPage;
    window.prevSignPreview = prevSignPreview;
    window.nextSignPreview = nextSignPreview;
    
    // Watermark functions
    window.setWatermarkPosition = setWatermarkPosition;
    window.executeWatermark = executeWatermark;
    window.downloadWatermarkedFile = downloadWatermarkedFile;
    window.prevWatermarkPage = prevWatermarkPage;
    window.nextWatermarkPage = nextWatermarkPage;
    window.prevWatermarkPreview = prevWatermarkPreview;
    window.nextWatermarkPreview = nextWatermarkPreview;
    
    // Rotate functions
    window.setRotationDegree = setRotationDegree;
    window.selectAllRotatePages = selectAllRotatePages;
    window.deselectAllRotatePages = deselectAllRotatePages;
    window.executeRotate = executeRotate;
    window.downloadRotatedFile = downloadRotatedFile;
    window.prevRotatePreview = prevRotatePreview;
    window.nextRotatePreview = nextRotatePreview;
    
    // Protect functions
    window.executeProtect = executeProtect;
    window.downloadProtectedFile = downloadProtectedFile;
    window.prevProtectPreview = prevProtectPreview;
    window.nextProtectPreview = nextProtectPreview;
  </script>
</body>
</html>

